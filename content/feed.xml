<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-04-24T17:33:52+08:00</updated><id>/</id><title type="html">Apache ServiceComb (incubating)</title><subtitle>The homepage of ServiceComb</subtitle><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;&quot;/assets/images/ServiceComb-logo-3.jpg&quot;, &quot;bio&quot;=&gt;&quot;ServiceComb is a microservice framework that provides service registration, discovery, configuration and management utilities.&quot;, &quot;biocn&quot;=&gt;&quot;ServiceComb提供了一套关于服务注册，服务发现，服务配置以及管理功能的微服务框架&quot;, &quot;location&quot;=&gt;&quot;China&quot;, &quot;locationcn&quot;=&gt;&quot;中国&quot;, &quot;email&quot;=&gt;&quot;servicecomb-developers@googlegroups.com&quot;, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;&quot;ServiceComb&quot;, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil}</name><email>servicecomb-developers@googlegroups.com</email></author><entry xml:lang="cn"><title type="html">使用gradle构建基于Java Chassis开发的微服务</title><link href="/cn/docs/build-java-chassis-microservices-using-gradle/" rel="alternate" type="text/html" title="使用gradle构建基于Java Chassis开发的微服务" /><published>2018-04-13T00:00:00+08:00</published><updated>2018-04-13T09:18:43+08:00</updated><id>/cn/docs/build-java-chassis-microservices-using-gradle</id><content type="html" xml:base="/cn/docs/build-java-chassis-microservices-using-gradle/">&lt;p&gt;maven和gradle都是Java世界中常用的构建工具。在&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis&quot;&gt;Java Chassis&lt;/a&gt;项目中采用了maven作为其构建工具，并在maven中心仓库定期发布其最新稳定版。然而，鉴于gradle最新发布版(4.6.0)还不支持maven的统一版本管理(BOM)功能，则在使用gradle构建基于Java Chassis开发的微服务时，需要用到Spring的&lt;a href=&quot;https://github.com/spring-gradle-plugins/dependency-management-plugin&quot;&gt;依赖管理插件&lt;/a&gt;来引入Java Chassis的版本管理来统一依赖项的版本从而避免产生版本冲突。&lt;/p&gt;

&lt;p&gt;在maven中，Java Chassis的依赖管理通过以下方式即可引入：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.servicecomb&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;java-chassis-dependencies&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0.0-m1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;type&amp;gt;&lt;/span&gt;pom&lt;span class=&quot;nt&quot;&gt;&amp;lt;/type&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;import&lt;span class=&quot;nt&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在gradle中，则需要以下三步完成，具体可参考 ：&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/pull/640/files#diff-8d0fdb4970d74d053b6585c3d5ae4cc2R36&quot;&gt;Java Chassis的PR-640&lt;/a&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;声明使用maven仓库及依赖管理插件的依赖&lt;/p&gt;

    &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;buildscript&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;repositories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mavenLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mavenCentral&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;classpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'io.spring.gradle:dependency-management-plugin:1.0.4.RELEASE'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启用依赖管理插件&lt;/p&gt;

    &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;plugin:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'io.spring.dependency-management'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;声明Java Chassis的统一依赖管理&lt;/p&gt;

    &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;dependencyManagement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;imports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mavenBom&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'org.apache.servicecomb:java-chassis-dependencies:1.0.0-m1'&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在每个子模块中都需要进行上述三步配置。&lt;/p&gt;

&lt;p&gt;对统一版本管理配置完成后，可增加程序运行入口使得命令行下也能方便的通过gradle运行应用，以便快速验证。其中，可将应用分为Spring Boot应用和非Spring Boot应用来为其添加启动入口：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Spring Boot应用&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;声明使用maven仓库及Spring Boot插件的依赖&lt;/p&gt;

        &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;buildscript&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;classpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;org.springframework.boot:spring-boot-gradle-plugin:1.4.5.RELEASE&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;repositories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mavenLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mavenCentral&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;启用Spring Boot插件&lt;/p&gt;

        &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;plugin:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'org.springframework.boot'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非Spring Boot应用&lt;/p&gt;

    &lt;p&gt;非Spring Boot应用只需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;application&lt;/code&gt;插件并指明应用入口方法即可：&lt;/p&gt;

    &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;plugin:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'application'&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;mainClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'org.packageName.XXXMain'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Eric Lee</name><email>eric.lee.ltk@gmail.com</email><uri>https://eric-lee-ltk.github.io</uri></author><category term="gradle" /></entry><entry xml:lang="cn"><title type="html">ServiceComb数据一致性解决方案Saga演进介绍</title><link href="/cn/docs/saga_pack_design/" rel="alternate" type="text/html" title="ServiceComb数据一致性解决方案Saga演进介绍" /><published>2018-04-04T00:00:00+08:00</published><updated>2018-04-04T09:18:43+08:00</updated><id>/cn/docs/saga-pack-design</id><content type="html" xml:base="/cn/docs/saga_pack_design/">&lt;p&gt;传统的单体应用的微服务化改造过程中大多会面临数据库拆分，故而原来由数据库保证的数据一致性也一定面临重新设计和实现，此时需要引入分布式数据一致性方案来解决。常见的解决方案主要有2PC，TCC，事件驱动等，而在微服务开源项目 ServiceComb中提出并实现了使用Saga&lt;a href=&quot;https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf&quot;&gt;[1]&lt;/a&gt;来解决微服务的数据一致性难题，不同方案的对比可参考《ServiceComb中的数据最终一致性方案》&lt;a href=&quot;http://blog.csdn.net/fl63zv9zou86950w/article/details/78393439&quot;&gt;[2]&lt;/a&gt;一文。Saga是一个数据最终一致性的解决方案，它允许我们成功地执行所有事务，或在任何事务失败的情况下，补偿已成功的事务，并提供了ACID&lt;a href=&quot;https://en.wikipedia.org/wiki/ACID&quot;&gt;[3]&lt;/a&gt;中ACD的保证（由于事务是交错执行的，可能会看到其他事务的部分结果，因此不能满足隔离性要求）。因此，Saga适用于以下跨服务的事务场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;嵌套调用&lt;/strong&gt;。如网上购物时，会依次经过下单、支付服务和第三方支付这几个子事务，其中，下单依赖于支付服务的返回状态，而支付服务也包含了多种可选的支付方式，并依赖于具体支付方式返回的结果。通过Saga，可以清晰地看到一个完整事务中各个服务之间的关系，在异常时也能快速定位出现问题的子事务。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;高并发&lt;/strong&gt;。如秒杀场景下，在成功扣除库存和完成支付后方可认为秒杀成功，若成功扣除库存但支付失败则自动进行补偿（即恢复库存）。鉴于Saga只有提交和补偿两种状态，成功场景下只需对每个子事务进行一次调用即可，因此可以在高并发下保持高性能。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;调用时间长&lt;/strong&gt;。如线上购买电影票，选好座位后一般会有15分钟的支付时间。Saga仅在子事务的提交阶段对资源进行短暂的锁定，且通过超时机制确保事务超时后能自动补偿，即在规定时间内没有支付成功的话就自动释放锁定的座位，极大地简化了业务出现异常时的处理逻辑。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;saga新版本演进&quot;&gt;Saga新版本演进&lt;/h2&gt;

&lt;p&gt;新年新气象，Apache ServiceComb(incubating) Saga&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-saga&quot;&gt;[4]&lt;/a&gt;（以下简称Saga）进行了演进。相对于上一版&lt;a href=&quot;http://blog.csdn.net/fl63zv9zou86950w/article/details/78393439&quot;&gt;[2]&lt;/a&gt;，新演进的设计主要有以下优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;极大提升易用性&lt;/strong&gt;。开发者只需使用2-3个注解（即启用事务服务：EnableOmega、全局事务标记：SagaStart和子事务标记：Compensable）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;更方便扩展&lt;/strong&gt;。对微服务框架的支持更友好。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据一致性与业务逻辑解耦&lt;/strong&gt;。在演进后的设计中，通过服务侧omega的引入，saga协调器的职责更为单一（只需负责协调事务的完整性），与具体业务无关，因此，开发人员可以聚焦在具体业务的开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Saga演进后的架构，如下图所示，主要包含两个组件，即alpha和omega，其中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;alpha充当协调者的角色，主要负责对事务的事件进行持久化存储以及协调子事务的状态，使其最终得以与全局事务的状态保持一致，即保证事务中的子事务要么全执行，要么全不执行。&lt;/li&gt;
  &lt;li&gt;omega是微服务中内嵌的一个agent，负责对网络请求进行拦截并向alpha上报事务事件，并在异常情况下根据alpha下发的指令执行相应的补偿或重试操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/pack.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;omega内部运行机制&quot;&gt;omega内部运行机制&lt;/h2&gt;

&lt;p&gt;omega是微服务中内嵌的一个agent，负责向alpha上报事务状态并与其它omega直接传递事务上下文信息。其中，每个服务的事务上下文包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;全局事务id(Global Tx Id)：用于唯一标识全局事务，一般在全局事务入口生成，并在整个事务过程中传递。&lt;/li&gt;
  &lt;li&gt;本地事务id(Local Tx Id)：用于唯一标识本地事务，一般由本地事务生成。&lt;/li&gt;
  &lt;li&gt;父事务id(Parent Tx Id)：用于构建子事务间的关系，可由请求上下文中构建。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如下图所示，分布式事务与用于分布式调用链追踪的zipkin&lt;a href=&quot;https://github.com/openzipkin/zipkin&quot;&gt;[5]&lt;/a&gt;的处理流程很类似，在服务提供方，omega会将请求拦截并从中提取请求信息中的全局事务id作为其自身的全局事务id（即Saga事件id），并将请求中的本地事务id作为其父事务id，且使用新生成的id作为本地事务id；在服务消费方，omega会将请求拦截并往其中添加当前的全局事务id和本地事务id。通过服务提供方和服务消费方的这种协作处理，子事务能连接起来形成一个完整的全局事务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/id_flow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;omega在预处理阶段会先向alpha发送事务开始的事件，在后处理阶段会再向alpha发送事务结束的事件。alpha在收到事件后会进行持久化的存储。因此，每个成功的子事务都有一一对应的开始及结束事件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/omega_internal.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在omega启动时会向alpha注册，使得异常或者超时场景下，alpha能通过回调向omega发送重试或补偿的命令和相应的调用参数，从而确保全局事务的一致性。&lt;/p&gt;

&lt;h2 id=&quot;具体处理流程&quot;&gt;具体处理流程&lt;/h2&gt;

&lt;h3 id=&quot;成功场景&quot;&gt;成功场景&lt;/h3&gt;

&lt;p&gt;全局事务开始前omega会先向alpha发送全局事务开始的事件，并在所有子事务完成时向alpha发送全局事务结束的事件。而每个子事务在执行前也会向alpha发送事务开始的事件，在成功执行后，会向alpha发送事务结束的事件。子事务间通过全局事务id连接在一起，但也因本地事务id而有所区分。因此，在成功场景下，每个开始的事件都会有对应的结束事件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/successful_scenario.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;异常场景&quot;&gt;异常场景&lt;/h3&gt;

&lt;p&gt;在子事务执行期间抛出异常时，omega会向alpha上报aborted事件，然后alpha会向该全局事务的其它已完成的子事务发送补偿指令，确保最终同一全局事务下的所有子事务要么都成功，要么都回滚。由于事务中没有明确指定全局事务中的参与者，因此，alpha的扫描器会定期查询事件表并找出已完成所有补偿子事务的全局事务，然后对这些全局事务添加全局事务结束事件以保证事务的完整性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/exception_scenario.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;超时场景&quot;&gt;超时场景&lt;/h3&gt;

&lt;p&gt;alpha的扫描器会定期扫描正在处理的事件状态，若发现事件超时，则会记录相应的aborted事件，然后alpha会向该全局事务的其它已完成的子事务发送补偿指令来恢复至事务开始前的状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/timeout_scenario.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何使用&quot;&gt;如何使用？&lt;/h2&gt;

&lt;p&gt;Saga的使用主要涵盖两方面，alpha的启动及omega的使用。&lt;/p&gt;

&lt;h3 id=&quot;alpha的启动&quot;&gt;alpha的启动&lt;/h3&gt;

&lt;p&gt;alpha启动前需要先运行数据库PostgreSQL：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d -e &lt;span class=&quot;s2&quot;&gt;&quot;POSTGRES_DB=saga&quot;&lt;/span&gt; -e &lt;span class=&quot;s2&quot;&gt;&quot;POSTGRES_USER=saga&quot;&lt;/span&gt; -e &lt;span class=&quot;s2&quot;&gt;&quot;POSTGRES_PASSWORD=password&quot;&lt;/span&gt; -p 5432:5432 postgres
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在确保数据库正常启动后，即可运行alpha：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d -p 8090:8090 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;s2&quot;&gt;&quot;JAVA_OPTS=-Dspring.profiles.active=prd&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;s2&quot;&gt;&quot;spring.datasource.url=jdbc:postgresql://{docker.host.address}:5432/saga?useSSL=false&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  alpha-server:0.1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;omega的使用&quot;&gt;omega的使用&lt;/h3&gt;

&lt;p&gt;omega的使用很简单，以一个简化的转账业务为例，同一笔转账要么转入和转出都成功，要么都失败。在这样一个业务中引入Saga，只需简单几步即可：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;引入依赖
    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.servicecomb.saga&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;omega-spring-starter&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.1.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.servicecomb.saga&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;omega-transport-resttemplate&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.1.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;添加Saga的注解及相应的补偿方法
2.1 在应用入口添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;@EnableOmega&lt;/code&gt; 的注解来初始化omega的配置并与alpha建立连接。
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nd&quot;&gt;@SpringBootApplication&lt;/span&gt;
 &lt;span class=&quot;nd&quot;&gt;@EnableOmega&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;SpringApplication&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;2.2 在全局事务的起点添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;@SagaStart&lt;/code&gt; 的注解。&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nd&quot;&gt;@SagaStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transferMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;transferOut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;transferIn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;2.3 在子事务处添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;@Compensable&lt;/code&gt; 的注解并指明其对应的补偿方法。其中，补偿方法的形参列表需与子事务方法的形参列表保持一致。&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nd&quot;&gt;@Compensable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compensationMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cancel&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transferOut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;repo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reduceBalanceByUsername&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;repo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addBalanceByUsername&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;2.4 对转入服务重复第2.3步即可。&lt;/p&gt;

    &lt;p&gt;2.5 在每个服务的application.yaml中添加配置项，指明服务信息和alpha的地址信息：&lt;/p&gt;
    &lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;s&quot;&gt;spring&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;s&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;application.name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;alpha&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;s&quot;&gt;cluster&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;s&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;alpha.cluster.addresses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目前Saga的实现还存在着很多有意思且有挑战性的课题，如alpha的协调调度实现、幂等的实现及自动补偿的实现等，欢迎有志之士与我们携手一起解决数据一致性的难题，共同为完善微服务生态贡献自己的力量。&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;[1] Sagas, Hector Garcia-Molina &amp;amp; Kenneth Salem, &lt;a href=&quot;https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf&quot;&gt;https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] ServiceComb中的数据最终一致性方案，殷湘，&lt;a href=&quot;http://blog.csdn.net/fl63zv9zou86950w/article/details/78393439&quot;&gt;http://blog.csdn.net/fl63zv9zou86950w/article/details/78393439&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] ACID, Wikipedia, &lt;a href=&quot;https://en.wikipedia.org/wiki/ACID&quot;&gt;https://en.wikipedia.org/wiki/ACID&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[4] Apache ServiceComb(incubating) Saga, Apache, &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-saga&quot;&gt;https://github.com/apache/incubator-servicecomb-saga&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5] zipkin, zipkin, &lt;a href=&quot;https://github.com/openzipkin/zipkin&quot;&gt;https://github.com/openzipkin/zipkin&lt;/a&gt;&lt;/p&gt;</content><author><name>Eric Lee</name><email>eric.lee.ltk@gmail.com</email><uri>https://eric-lee-ltk.github.io</uri></author><category term="saga" /><summary type="html">Saga演进介绍</summary></entry><entry xml:lang="cn"><title type="html">如何加入ServiceComb社区</title><link href="/cn/docs/join_the_community/" rel="alternate" type="text/html" title="如何加入ServiceComb社区" /><published>2018-04-04T00:00:00+08:00</published><updated>2017-09-16T19:05:00+08:00</updated><id>/cn/docs/join_the_community</id><content type="html" xml:base="/cn/docs/join_the_community/">&lt;p&gt;近期，热衷开源和微服务的伙伴们非常关注如何加入到ServiceComb社区。ServiceComb作为开源的Apache 孵化项目，加入方式和常规的加入开源社区的方式大体一致，一般为三个阶段：1. 订阅并关注社区动态；2. 开始在开源社区提交第一份代码；3. 深度加入社区讨论并贡献，以下将详细向大家讲述如何一步步加入ServiceComb社区。&lt;/p&gt;

&lt;h3 id=&quot;step-1-订阅并关注servicecomb社区动态&quot;&gt;Step 1 订阅并关注ServiceComb社区动态&lt;/h3&gt;

&lt;p&gt;订阅和关注社区动态的途径有：即时通讯工具（社区微信群、gitter）、社区公众号、开发者邮件列表、门户网站。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;即时通讯工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;扫描下方二维码或搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;ServiceComb小助手&lt;/code&gt;加入微信群，加入后可以在微信群中咨询和求助，会有热心的伙伴和committer 及时的响应回复。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/assist.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也可使用Github账号登录gitter（地址 https://gitter.im/ServiceCombUsers/Lobby）进行在线讨论，国内的伙伴们更习惯于使用微信群进行在线交流，但为了更方便后来加入的人可以检索并查阅前期的讨论内容存档，所以ServiceComb社区推荐使用gitter。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;社区公众号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;扫描下方二维码关注公众号或微信公众号中搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;ServiceComb&lt;/code&gt;进行关注，公众号会定期的发布和推送ServiceComb近期相应资讯（干货资料、学习资源、线上活动、线下活动等）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/public.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;邮件列表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过订阅开发者邮件可以及时获取到社区开发者的邮件讨论内容，可发起讨论，也可通过回复感兴趣的讨论题目参与到讨论中（邮件内容均使用英文），另外邮件的存档功能可以方便开发者查阅历史问题的讨论过程。&lt;/p&gt;

&lt;p&gt;订阅邮件方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发送任意内容到&lt;code class=&quot;highlighter-rouge&quot;&gt;dev-subscribe@servicecomb.incubator.apache.org&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;收到来自dev-help的邮件后，再回复任意内容来确认订阅邮件列表即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;邮件存档内容可通过https://www.mail-archive.com/搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;ServiceComb&lt;/code&gt;获取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;门户网站&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ServiceComb门户网站是社区的官方入口，包括快速入门指南、用户手册、开发者手册、常见问题和开发博文等。&lt;/p&gt;

&lt;p&gt;网站地址: http://servicecomb.incubator.apache.org/cn/&lt;/p&gt;

&lt;h3 id=&quot;step-2-在-servicecomb-社区提交第一份代码pr&quot;&gt;Step 2 在 ServiceComb 社区提交第一份代码（PR）&lt;/h3&gt;

&lt;p&gt;当关注社区并尝试调试使用后，会发现一些简单的bug（如文档或代码格式问题等），可以通过fix简单的bug来熟悉ServiceComb社区的开发流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发现问题并提交Issue：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于ServiceComb的任务管理是在Apache JIRA上进行的，所以需要先注册并登录到JIRA。关于JIRA详细使用方法请参考JIRA使用帮助：http://servicecomb.incubator.apache.org/cn/developers/use-jira/&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;注册并登陆到 https://issues.apache.org/jira/projects/SCB，点击左侧Kanban可以看到当前待处理、处理中和已经完成的任务列表。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira-kanban.png&quot; alt=&quot;kanabn&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击&lt;strong&gt;新建&lt;/strong&gt;创建新的issue或者task进行问题或任务跟踪，选择相应的模块并添加描述信息。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/jira/create-issue.png&quot; alt=&quot;create&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任务提交到JIRA后，需要在本地进行代码开发，进行第一份代码的提交。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提交第一份代码（PR）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开发者在GitHub上fork仓库后clone到本地进行代码修改，修改完成并测试通过后可以创建PR提交代码，提交PR后系统会自动运行CI进行代码测试。测试通过后会有其他开发者或者maintainer进行review，没有问题后会被approve并merge到主干分支。具体可参考门户网站上开发者手册中的代码提交指南：&lt;/p&gt;

&lt;p&gt;http://servicecomb.incubator.apache.org/cn/developers/submit-codes/&lt;/p&gt;

&lt;p&gt;需要&lt;strong&gt;注意&lt;/strong&gt;的是，创建PR的时候，PR的title要以JIRA中对应的问题编号开头，如下图中 [SCB-327]，这样系统就会自动关联本次提交到相应JIRA任务下，方便进度跟踪。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/pr.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;刚才提交的代码经过committer的review后，如果有问题committer会进行comment，继续修改后push最新代码即可。如果没有问题会approve并merge。&lt;/p&gt;

&lt;p&gt;至此，您已经熟悉了ServiceComb社区的初级的开发流程，也是常规的社区开发方法（不同的社区承载体会有细微差异，如kubernetes的问题跟踪是直接承载github的issue上）。下一步就可以深度参与到ServiceComb的讨论并进行贡献。&lt;/p&gt;

&lt;h3 id=&quot;step-3-深度参与到servicecomb讨论并贡献&quot;&gt;Step 3 深度参与到ServiceComb讨论并贡献&lt;/h3&gt;

&lt;p&gt;由于开源社区强调开放性，当开发者想在社区里做一些较大或中长期的特性时，则需在ServiceComb社区发起特性的讨论。&lt;/p&gt;

&lt;h4 id=&quot;如何发起特性讨论&quot;&gt;如何发起特性讨论&lt;/h4&gt;

&lt;p&gt;通过邮件发Proposal到社区进行讨论，Proposal中有贴图或附加文档时可先创建好文件链接，将链接贴到邮件里即可，创建文件可以有一下两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在JIRA上创建一个对应的特性任务，并将Proposal文档添加到该任务的附件中，拷贝链接。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过github向servicecomb.io网站以blog的形式提交文件，将该blog地址拷贝到邮件中。&lt;/p&gt;

    &lt;p&gt;文档附件可参考：&lt;/p&gt;

    &lt;p&gt;http://servicecomb.incubator.apache.org/docs/service-registry-refactor-proposal/&lt;/p&gt;

    &lt;p&gt;Proposal邮件参考：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/jira/proposal-pack.png&quot; alt=&quot;proposal-pack&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当在邮件中讨论清楚特性设计后，就可以开始对应的代码开发，或对于部分小的任务（如代码bug修复、文档完善、网站优化等），其本身不需要过多讨论，则可参考上一步骤 Step 2 中的开发流程进行代码贡献。&lt;/p&gt;

&lt;p&gt;遇到其他本文章未解决的问题（如用户业务准备进行微服务技术选型或ServiceComb的概念性问题等）时，建议直接到微信群或者gitter里进行咨询并寻求帮助。&lt;/p&gt;

&lt;p&gt;社区鼓励多劳多得和技术沉淀，坚持贡献社区可以收获来自社区的礼品激励惊喜，坚持长期使用和参与社区项目的伙伴，将可能被选举成 Apache committer 或者取得更高的荣誉，希望本文能对热衷开源及ServiceComb社区的伙伴们有所帮助，也欢迎积极参加ServiceComb的线上及线下活动。&lt;/p&gt;</content><author><name>Li Bo</name><email>libo75@huawei.com</email></author><category term="加入社区" /><summary type="html">如何加入ServiceComb社区</summary></entry><entry xml:lang="cn"><title type="html">ServiceComb示例讲解微服务配置中心选型与对接</title><link href="/cn/docs/config_center_integration/" rel="alternate" type="text/html" title="ServiceComb示例讲解微服务配置中心选型与对接" /><published>2018-04-04T00:00:00+08:00</published><updated>2018-04-04T19:05:00+08:00</updated><id>/cn/docs/config-center-integration</id><content type="html" xml:base="/cn/docs/config_center_integration/">&lt;h3 id=&quot;配置中心&quot;&gt;配置中心&lt;/h3&gt;

&lt;p&gt;项目代码中经常会用到各种配置项，比如下面的代码中是从系统环境变量中获取&lt;code class=&quot;highlighter-rouge&quot;&gt;prop&lt;/code&gt; :&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEFAULT_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NumberFormatException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// handle format issues&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;类似使用环境变量或者&lt;code class=&quot;highlighter-rouge&quot;&gt;properties&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;等文件方式传入配置进而控制应用表现的方法广泛应用于开发过程中，这样做可以将外部配置与业务代码解耦，若有变动只需修改配置参数而不需要重新编译构建项目。但是这种将配置和代码放在一起的方式可能会泄露隐私信息（比如密码），因为代码可能会公开，出于安全的考虑，配置和代码分离管理的方式开始广泛使用，常见的方法比如将配置放在CI服务器上通过打包脚本打入应用包中，或者直接放到运行应用的服务器的特定目录下，或者存储到数据库中。这种方式在传统的单体应用中简单有效，但也带来一些新的挑战：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;配置变化频繁时，需要频繁的打包部署应用&lt;/li&gt;
  &lt;li&gt;不同的环境下配置项不同需要分开管理（比如测试环境和生产环境）&lt;/li&gt;
  &lt;li&gt;配置项中的隐私信息虽然避免了随代码公开而泄露，但是还是会打包到应用包中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，面对微服务爆发式增长的应用数量和服务器数量带来新的困难&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;复杂的业务对应大量的配置项&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;配置项在不同服务中可能出现冲突&lt;/li&gt;
  &lt;li&gt;对集群部署的应用配置进行修改时需要一次修改每个机器上的应用配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种背景下，中心化的配置服务即配置中心应运而生，简单来说，配置中心就是一种统一管理各种应用配置的基础服务组件，一个合格的配置中心需要满足：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;配置项容易读取和修改&lt;/li&gt;
  &lt;li&gt;添加新配置要简单直接&lt;/li&gt;
  &lt;li&gt;支持对配置的修改的检视以把控风险&lt;/li&gt;
  &lt;li&gt;可以查看配置修改的历史记录&lt;/li&gt;
  &lt;li&gt;不同部署环境支持隔离&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开源社区目前主流的配置中心有spring-cloud-config, ctrip apollo, disconf 等，下表是对其功能特性、技术路线、可用性和易用性等发面的比较[1]供参考。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;spring-cloud-config&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ctrip apollo&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;disconf&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;静态配置管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;基于file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;动态配置管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;统一管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无，需要github&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;多维度管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无，需要github&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;本地配置缓存&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;配置生效时间&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;重启或手动refresh生效&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;实时&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;实时&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;配置更新推送&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;手动触发&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;配置定时拉取&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;依赖时事件驱动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;授权、审核、审计&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无，需要github&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;配置版本管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;git做版本管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;界面上提供发布历史和回滚按钮&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;操作记录存数据库，无查询接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;实例配置监控&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;需要结合springadmin&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;灰度发布&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持部分更新&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;告警通知&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持，邮件方式告警&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持，邮件方式告警&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;多数据中心部署&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;配置界面&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无，通过git操作&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;统一界面&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;统一界面&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;综合比较后，ServiceComb选择了Apollo[2]作为配置中心进行对接。Apollo是携程框架部门研发并贡献到开源社区的分布式配置中心，活跃贡献者近百人。最新版本的ServiceComb Java Chassis已实现支持Apollo[1]，用户可以使用该配置中心结合Chassis中集成的Archaius实现在不需要重新启动或重新部署应用的前提下进行配置项的集中管理和动态修改。基于ServiceComb优秀的插件化设计，用户可以非常简单的对接到其他开源或自研的配置中心。&lt;/p&gt;

&lt;h3 id=&quot;使用简介&quot;&gt;使用简介&lt;/h3&gt;

&lt;h5 id=&quot;启动apollo服务&quot;&gt;启动Apollo服务&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;启动Apollo服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apollo服务可以通过docker或二进制启动，方法参考官网文档[3]，推荐使用docker启动。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/lijasonvip/apollo-image-for-servicecomb.git
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;apollo-image-for-servicecomb &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; docker-compose up
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;出现&lt;code class=&quot;highlighter-rouge&quot;&gt;apollo-quick-start | Portal started. You can visit http://localhost:8070 now!&lt;/code&gt;后表示Apollo已经启动成功，浏览器访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8070&lt;/code&gt;即可访问&lt;code class=&quot;highlighter-rouge&quot;&gt;portal&lt;/code&gt;服务，默认登录账号为&lt;code class=&quot;highlighter-rouge&quot;&gt;apollo/admin&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建应用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;登录后点击创建项目，填入应用名称，其他选默认即可，创建应用后需要进入应用点击发布才能生效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/config/create-project.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生成TOKEN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应用发布后我们需要获取一个TOKEN，在&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8070/open/manage.html&lt;/code&gt;页面填入刚才创建的应用ID和应用名称并选择项目和部门信息后点击创建即可生成一个TOKEN，保存此TOKEN并配置到Chassis应用的配置文件中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/config/token.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;引入依赖&quot;&gt;引入依赖&lt;/h5&gt;

&lt;p&gt;在Chassis应用的pom文件中引入依赖&lt;code class=&quot;highlighter-rouge&quot;&gt;config-apollo&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.servicecomb&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;config-apollo&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;添加配置&quot;&gt;添加配置&lt;/h5&gt;

&lt;p&gt;在Chassis应用的配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;microservice.yaml&lt;/code&gt;中增加以下配置：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;s&quot;&gt;apollo&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;s&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;serverUri&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http://127.0.0.1:8070&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;		&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#Apollo portal服务地址&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;serviceName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;SampleApp&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;				&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#创建应用时的AppID&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;DEV&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;								&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#env默认是DEV&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;clusters&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;					&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#cluster默认default&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;				&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#namespace默认application&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;de3c5b2e6d8535b96&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;				&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#第一步中生成的TOKEN&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;refreshInterval&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;					&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#自动拉取配置的时间间隔&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，通过简单的4步应用已经成功的对接到了Apollo配置中心，启动应用后可以在Apollo页面通过对配置项的新增、更新、回滚等操作进行服务治理啦！Demo参考[4]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/config/configuration.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;对接配置中心&quot;&gt;对接配置中心&lt;/h3&gt;

&lt;p&gt;Chassis动态配置基于Netflix的Archaius实现[5]，Archaius扩展数据源方法参考文档[6]和demo[7]，Chassis按照[6]扩展了&lt;code class=&quot;highlighter-rouge&quot;&gt;PolledConfigurationSource&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractPollingScheduler&lt;/code&gt;，启动的时候用SPI机制找到Source接口的实现类。&lt;/p&gt;

&lt;p&gt;对接到一个新的配置中心只要扩展实现&lt;code class=&quot;highlighter-rouge&quot;&gt;ConfigCenterConfigurationSource&lt;/code&gt;接口，实现&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;方法，在&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;方法中实现连接配置中心，刷新配置项的逻辑即可。具体代码请参考[8]。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;设计配置项&lt;/p&gt;

    &lt;p&gt;对接到新的配置中心可以设计新的配置参数，定义新的工具类获取这些参数，并指定默认值，参考&lt;code class=&quot;highlighter-rouge&quot;&gt;ApolloConfig&lt;/code&gt;类对新增&lt;code class=&quot;highlighter-rouge&quot;&gt;apollo.config.serverUri&lt;/code&gt;等参数的处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;扩展Source接口&lt;/p&gt;

    &lt;p&gt;init函数实现固定时间间隔或实时获取配置中心的配置项逻辑。&lt;code class=&quot;highlighter-rouge&quot;&gt;ApolloClient&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;refreshApolloConfig&lt;/code&gt;函数启动了一个定时执行的线程刷新配置项：&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;refreshApolloConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EXECUTOR&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;scheduleWithFixedDelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigRefresh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serviceUri&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; 
                                &lt;span class=&quot;n&quot;&gt;firstRefreshInterval&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
                                &lt;span class=&quot;n&quot;&gt;refreshInterval&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
                                &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConfigRefresh&lt;/code&gt;线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;中会从Apollo配置中心获取最新配置项并和之前的配置项对比分析出新增、修改和删除的配置参数，然后去执行对应的更新操作。对配置项的修改更新都是基于Archaius的&lt;code class=&quot;highlighter-rouge&quot;&gt;WatchedUpdateListener&lt;/code&gt; 进而实现应用内参数的动态更新。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;加入servicecomb社区&quot;&gt;加入ServiceComb社区&lt;/h3&gt;

&lt;p&gt;ServiceComb目前在Apache基金会孵化，诚挚的欢迎开发者和用户一起参与社区讨论和贡献，加入社区的方法有订阅邮件列表，关注微信公众号，加入社区微信群等，详细方法请参考[9]。&lt;/p&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;[0] ServiceComb 项目地址 &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis&quot;&gt;https://github.com/apache/incubator-servicecomb-java-chassis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[1] 开源配置中心比较 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/FAQ&quot;&gt;https://github.com/ctripcorp/apollo/wiki/FAQ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] ctrip apollo &lt;a href=&quot;https://github.com/ctripcorp/apollo/&quot;&gt;https://github.com/ctripcorp/apollo/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] Apollo启动 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Quick-Start&quot;&gt;https://github.com/ctripcorp/apollo/wiki/Quick-Start&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[4] Chassis应用使用Apollo配置中心Demo &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/samples/config-apollo-sample&quot;&gt;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/samples/config-apollo-sample&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5] Netflix Archaius &lt;a href=&quot;https://github.com/Netflix/archaius/&quot;&gt;https://github.com/Netflix/archaius/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[6] Archaius 扩展数据源 &lt;a href=&quot;https://github.com/Netflix/archaius/wiki/Users-Guide&quot;&gt;https://github.com/Netflix/archaius/wiki/Users-Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[7] Archaius 对接Redis Demo &lt;a href=&quot;https://github.com/cnwrinc/archaius-redis&quot;&gt;https://github.com/cnwrinc/archaius-redis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[8] Chassis对接配置中心代码 &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/dynamic-config/config-apollo&quot;&gt;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/dynamic-config/config-apollo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[9] 加入ServiceComb社区 &lt;a href=&quot;https://servicecomb.incubator.apache.org/cn/docs/join_the_community&quot;&gt;https://servicecomb.incubator.apache.org/cn/docs/join_the_community&lt;/a&gt;&lt;/p&gt;</content><author><name>Li Bo</name><email>libo75@huawei.com</email></author><category term="配置中心" /><summary type="html">ServiceComb对接配置中心</summary></entry><entry xml:lang="en"><title type="html">Howto Upgrade to Zipkin2</title><link href="/docs/howto-upgrade-topzipkin2/" rel="alternate" type="text/html" title="Howto Upgrade to Zipkin2" /><published>2018-01-10T00:00:00+08:00</published><updated>2018-01-11T10:26:28+08:00</updated><id>/docs/howto-upgrade-to-zipkin-v2</id><content type="html" xml:base="/docs/howto-upgrade-topzipkin2/">&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;Java Chassis uses zipkin as the default tracing implementation.&lt;/p&gt;

&lt;p&gt;Zipkin introduced &lt;a href=&quot;http://zipkin.io/zipkin-api/#/&quot;&gt;v2 http api&lt;/a&gt; in version 1.31 which simplifies data types. There are also various other improvements and new features added to the zipkin libraries, so it seems a good time for us to follow the upstream and upgrade to zipkin2.&lt;/p&gt;

&lt;h3 id=&quot;version-matrix&quot;&gt;Version matrix&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;module&lt;/th&gt;
      &lt;th&gt;current&lt;/th&gt;
      &lt;th&gt;target&lt;/th&gt;
      &lt;th&gt;supports v2 since&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;zipkin&lt;/td&gt;
      &lt;td&gt;1.24.0&lt;/td&gt;
      &lt;td&gt;2.4.2&lt;/td&gt;
      &lt;td&gt;2.0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;brave&lt;/td&gt;
      &lt;td&gt;4.13.1&lt;/td&gt;
      &lt;td&gt;4.13.1&lt;/td&gt;
      &lt;td&gt;4.7.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;reporter&lt;/td&gt;
      &lt;td&gt;0.10.0&lt;/td&gt;
      &lt;td&gt;2.2.2&lt;/td&gt;
      &lt;td&gt;2.0.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;whats-changed&quot;&gt;What’s changed&lt;/h2&gt;

&lt;p&gt;Zipkin did a very good job on maintaining backward compatibility. All the changes that breaks compatiblity are packaged into a new group(&lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.java&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.zipkin2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.reporter&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.reporter2&lt;/code&gt;). And v1/v2 libraries can coexist.&lt;/p&gt;

&lt;p&gt;The zipkin2 library can use both v1 and v2 api to communicate with server.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;zipkin2.Span&lt;/code&gt; class changed a bit from the old &lt;code class=&quot;highlighter-rouge&quot;&gt;zipkin.Span&lt;/code&gt; class. The public fields are refactored to methods. And the &lt;code class=&quot;highlighter-rouge&quot;&gt;BinaryAnnotation&lt;/code&gt; class is removed along with &lt;code class=&quot;highlighter-rouge&quot;&gt;zipkin.Span.binaryAnnotaions&lt;/code&gt; field. It’s functionality is replaced by &lt;code class=&quot;highlighter-rouge&quot;&gt;zipkin2.Span.tags()&lt;/code&gt; method which return a &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&amp;lt;String,String&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;upgrade-to-zipkin2-for-java-chassis&quot;&gt;Upgrade to zipkin2 for Java Chassis&lt;/h2&gt;

&lt;h3 id=&quot;modify-the-maven-dependencies-to-use-the-target-version-of-related-libraries&quot;&gt;Modify the maven dependencies to use the target version of related libraries.&lt;/h3&gt;
&lt;p&gt;Change the group &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.java&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.reporter&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.zipkin2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.reporter2&lt;/code&gt; respectively.&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java-chassis-dependencies/pom.xml
&lt;span class=&quot;gu&quot;&gt;@@ -50,8 +50,8 @@
&lt;/span&gt;     &amp;lt;cxf.version&amp;gt;3.1.6&amp;lt;/cxf.version&amp;gt;
     &amp;lt;logback.version&amp;gt;1.1.7&amp;lt;/logback.version&amp;gt;
     &amp;lt;brave.version&amp;gt;4.13.1&amp;lt;/brave.version&amp;gt;
&lt;span class=&quot;gd&quot;&gt;-    &amp;lt;zipkin.version&amp;gt;1.24.0&amp;lt;/zipkin.version&amp;gt;
-    &amp;lt;zipkin-reporter.version&amp;gt;0.10.0&amp;lt;/zipkin-reporter.version&amp;gt;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    &amp;lt;zipkin.version&amp;gt;2.4.2&amp;lt;/zipkin.version&amp;gt;
+    &amp;lt;zipkin-reporter.version&amp;gt;2.2.2&amp;lt;/zipkin-reporter.version&amp;gt;
&lt;/span&gt;   &amp;lt;/properties&amp;gt;
 
   &amp;lt;dependencyManagement&amp;gt;
&lt;span class=&quot;gu&quot;&gt;@@ -646,7 +646,7 @@
&lt;/span&gt; 
       &amp;lt;!-- zipkin dependencies --&amp;gt;
       &amp;lt;dependency&amp;gt;
&lt;span class=&quot;gd&quot;&gt;-        &amp;lt;groupId&amp;gt;io.zipkin.java&amp;lt;/groupId&amp;gt;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+        &amp;lt;groupId&amp;gt;io.zipkin.zipkin2&amp;lt;/groupId&amp;gt;
&lt;/span&gt;         &amp;lt;artifactId&amp;gt;zipkin&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;${zipkin.version}&amp;lt;/version&amp;gt;
       &amp;lt;/dependency&amp;gt;
&lt;span class=&quot;gu&quot;&gt;@@ -661,7 +661,7 @@
&lt;/span&gt;         &amp;lt;version&amp;gt;${brave.version}&amp;lt;/version&amp;gt;
       &amp;lt;/dependency&amp;gt;
       &amp;lt;dependency&amp;gt;
&lt;span class=&quot;gd&quot;&gt;-        &amp;lt;groupId&amp;gt;io.zipkin.reporter&amp;lt;/groupId&amp;gt;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+        &amp;lt;groupId&amp;gt;io.zipkin.reporter2&amp;lt;/groupId&amp;gt;
&lt;/span&gt;         &amp;lt;artifactId&amp;gt;zipkin-sender-okhttp3&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;${zipkin-reporter.version}&amp;lt;/version&amp;gt;
       &amp;lt;/dependency&amp;gt;

handlers/handler-tracing-zipkin/pom.xml
&lt;span class=&quot;gu&quot;&gt;@@ -50,7 +50,7 @@
&lt;/span&gt;       &amp;lt;artifactId&amp;gt;brave&amp;lt;/artifactId&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
&lt;span class=&quot;gd&quot;&gt;-      &amp;lt;groupId&amp;gt;io.zipkin.reporter&amp;lt;/groupId&amp;gt;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+      &amp;lt;groupId&amp;gt;io.zipkin.reporter2&amp;lt;/groupId&amp;gt;
&lt;/span&gt;       &amp;lt;artifactId&amp;gt;zipkin-sender-okhttp3&amp;lt;/artifactId&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;make-brave-to-use-zipkin2-instead-of-zipkin&quot;&gt;Make brave to use zipkin2 instead of zipkin&lt;/h3&gt;

&lt;p&gt;Change the zipkin.xxx import to zipkin2.xxx on imports, and most importantly, use &lt;code class=&quot;highlighter-rouge&quot;&gt;spanReporter()&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;reporter()&lt;/code&gt; for generating reporter for brave, change the api path to /api/v2/xxx when creating sender.&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;handlers/handler-tracing-zipkin/src/main/java/org/apache/servicecomb/tracing/zipkin/TracingConfiguration.java
&lt;span class=&quot;gu&quot;&gt;@@ -31,11 +31,11 @@
&lt;/span&gt; import brave.http.HttpTracing;
 import brave.propagation.CurrentTraceContext;
 import org.apache.servicecomb.config.DynamicProperties;
&lt;span class=&quot;gd&quot;&gt;-import zipkin.Span;
-import zipkin.reporter.AsyncReporter;
-import zipkin.reporter.Reporter;
-import zipkin.reporter.Sender;
-import zipkin.reporter.okhttp3.OkHttpSender;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+import zipkin2.Span;
+import zipkin2.reporter.AsyncReporter;
+import zipkin2.reporter.Reporter;
+import zipkin2.reporter.Sender;
+import zipkin2.reporter.okhttp3.OkHttpSender;
&lt;/span&gt; 
 @Configuration
 class TracingConfiguration {
&lt;span class=&quot;gu&quot;&gt;@@ -56,14 +56,15 @@ Sender sender(DynamicProperties dynamicProperties) {
&lt;/span&gt;     return AsyncReporter.builder(sender).build();
   }
 
&lt;span class=&quot;gi&quot;&gt;+
&lt;/span&gt;   @Bean
   Tracing tracing(Reporter&amp;lt;Span&amp;gt; reporter, DynamicProperties dynamicProperties,
       CurrentTraceContext currentTraceContext) {
     return Tracing.newBuilder()
         .localServiceName(dynamicProperties.getStringProperty(CONFIG_QUALIFIED_MICROSERVICE_NAME_KEY,
             DEFAULT_MICROSERVICE_NAME))
         .currentTraceContext(currentTraceContext) // puts trace IDs into logs
&lt;span class=&quot;gd&quot;&gt;-        .reporter(reporter)
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+        .spanReporter(reporter)
&lt;/span&gt;         .build();
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&quot;https://github.com/openzipkin/brave/releases/tag/4.7.1&quot;&gt;brave release notes&lt;/a&gt;, it’s stated that we need to use &lt;code class=&quot;highlighter-rouge&quot;&gt;create()&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;builder()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
   /** Configuration for how to buffer spans into messages for Zipkin */
&lt;span class=&quot;gd&quot;&gt;-  @Bean Reporter&amp;lt;Span&amp;gt; reporter() {
-    return AsyncReporter.builder(sender()).build();
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+  @Bean Reporter&amp;lt;Span&amp;gt; spanReporter() {
+    return AsyncReporter.create(sender()).build();
&lt;/span&gt;   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But this will not work. In &lt;code class=&quot;highlighter-rouge&quot;&gt;zipkin2.Reporter&lt;/code&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;create(sender)&lt;/code&gt; is actually equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;builder(sender).build()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncReporter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Span&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncReporter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncReporter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncReporter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;make-changes-according-to-the-changes-of-zipkinspan-and-zipkin2span&quot;&gt;Make changes according to the changes of zipkin.Span and zipkin2.Span.&lt;/h3&gt;

&lt;p&gt;We do not use zipkin.Span in our production code, but we do use it in our tests. Those changes are quite straight forward, we just change the accessing of fields to calling methods as described in the What’s Changed section.&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tracing/tracing-zipkin/src/test/java/org/apache/servicecomb/tracing/zipkin/ZipkinSpanAspectTest.java 
&lt;span class=&quot;gu&quot;&gt;@@ -45,7 +45,7 @@
&lt;/span&gt; import org.apache.servicecomb.tracing.zipkin.app.ZipkinSpanTestApplication;
 import org.apache.servicecomb.tracing.zipkin.app.ZipkinSpanTestApplication.CustomSpanTask;
 import org.apache.servicecomb.tracing.zipkin.app.ZipkinSpanTestApplication.SomeSlowTask;
&lt;span class=&quot;gd&quot;&gt;-import zipkin.Span;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+import zipkin2.Span;
&lt;/span&gt; 
 @RunWith(SpringRunner.class)
 @SpringBootTest(classes = {ZipkinSpanTestApplication.class, TracingConfig.class})
&lt;span class=&quot;gu&quot;&gt;@@ -74,8 +74,8 @@ public void reportedSpanContainsAnnotatedMethodInfo() throws Exception {
&lt;/span&gt; 
     await().atMost(2, SECONDS).until(() -&amp;gt; !spans.isEmpty());
 
&lt;span class=&quot;gd&quot;&gt;-    zipkin.Span span = spans.poll();
-    assertThat(span.name, is(&quot;crawl&quot;));
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    zipkin2.Span span = spans.poll();
+    assertThat(span.name(), is(&quot;crawl&quot;));
&lt;/span&gt;     assertThat(tracedValues(span), contains(SomeSlowTask.class.getMethod(&quot;crawl&quot;).toString()));
   }
   
&lt;span class=&quot;gu&quot;&gt;@@ -84,17 +84,17 @@ public void reportCustomSpanInfomation() throws Exception {
&lt;/span&gt;     customSpanTask.invoke();
     await().atMost(2, SECONDS).until(() -&amp;gt; !spans.isEmpty());
   
&lt;span class=&quot;gd&quot;&gt;-    zipkin.Span span = spans.poll();
-    assertThat(span.name, is(&quot;transaction1&quot;));
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    zipkin2.Span span = spans.poll();
+    assertThat(span.name(), is(&quot;transaction1&quot;));
&lt;/span&gt;     assertThat(tracedValues(span), contains(&quot;startA&quot;));
     
   }
 
&lt;span class=&quot;gd&quot;&gt;-  private List&amp;lt;String&amp;gt; tracedValues(zipkin.Span spans) {
-    return spans.binaryAnnotations.stream()
-        .filter(span -&amp;gt; CALL_PATH.equals(span.key) || &quot;error&quot;.equals(span.key))
-        .filter(span -&amp;gt; span.value != null)
-        .map(annotation -&amp;gt; new String(annotation.value))
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+  private List&amp;lt;String&amp;gt; tracedValues(zipkin2.Span spans) {
+    return spans.tags().entrySet().stream()
+        .filter(span -&amp;gt; CALL_PATH.equals(span.getKey()) || &quot;error&quot;.equals(span.getKey()))
+        .filter(span -&amp;gt; span.getValue() != null)
+        .map(annotation -&amp;gt; new String(annotation.getValue()))
&lt;/span&gt;         .distinct()
         .collect(Collectors.toList());
   }
&lt;span class=&quot;gu&quot;&gt;@@ -110,7 +110,7 @@ public void reportCustomSpanInfomation() throws Exception {
&lt;/span&gt;     Tracing tracing(Queue&amp;lt;Span&amp;gt; spans) {
       return Tracing.newBuilder()
           .currentTraceContext(new StrictCurrentTraceContext())
&lt;span class=&quot;gd&quot;&gt;-          .reporter(spans::add)
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+          .spanReporter(spans::add)
&lt;/span&gt;           .build();
     }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;support-both-v1-and-v2-api-of-zipkin-server&quot;&gt;Support both v1 and v2 api of zipkin server.&lt;/h3&gt;

&lt;p&gt;Our customers may be still running a zipkin server prior to 1.31 which does not support the v2 http api. So we added an option to let them specify the server api version.&lt;/p&gt;

&lt;p&gt;Supporting v1 api is built into zipkin2, so we do not need to rely on the v1 libraries. Just use the &lt;code class=&quot;highlighter-rouge&quot;&gt;SpanBytesEncoder.JSON_V1&lt;/code&gt; when building reporter and change the sender api path.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;URLConnectionSender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://localhost:9411/api/v1/spans&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;reporter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncReporter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SpanBytesEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;JSON_V1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That’s all, for the complete changes, please refer the &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/pull/488&quot;&gt;pull request&lt;/a&gt; for the complete changes.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/openzipkin/zipkin/releases/tag/2.0.0&quot;&gt;Zipkin 2.0.0 release notes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/openzipkin/brave/releases/tag/4.7.1&quot;&gt;Brave 4.7.1 release notes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/openzipkin/brave/tree/master/brave&quot;&gt;Brave API V4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Yang Bo</name><email>yangbo12@huawei.com</email></author><category term="zipkin" /><summary type="html">Changes between v1 and v2 of zipkin and how Java Chassis upgraded to zipkin2</summary></entry><entry xml:lang="en"><title type="html">Proposal for refactoring service registry module in Java Chassis</title><link href="/docs/service-registry-refactor-proposal/" rel="alternate" type="text/html" title="Proposal for refactoring service registry module in Java Chassis" /><published>2017-12-19T00:00:00+08:00</published><updated>2017-12-19T09:18:43+08:00</updated><id>/docs/service-registry-refactor-proposal</id><content type="html" xml:base="/docs/service-registry-refactor-proposal/">&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;The architecture of the &lt;code class=&quot;highlighter-rouge&quot;&gt;service registry&lt;/code&gt; module in Java Chassis is as follows.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/service_registry.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;However, it has the following problems:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Low level components access high level components frequently. The cyclic relationships make the implementation complicated and introduce some redundant access points.&lt;/li&gt;
  &lt;li&gt;Low level components should be stateless to be reused by high level components. Introducing state into low level components makes it relies heavily on the high level components, causing cyclic relationships.&lt;/li&gt;
  &lt;li&gt;Hard to integrate with third-party framework. It does not provide a standalone client with cache capability inside. It also requires the configurations should be loaded from dynamic properties.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proposed-architecture&quot;&gt;Proposed Architecture&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/proposed_architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The above architecture is what the &lt;code class=&quot;highlighter-rouge&quot;&gt;service registry&lt;/code&gt; module supposed to be in my opinion. The low level components like &lt;code class=&quot;highlighter-rouge&quot;&gt;ApiManager&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;UriManager&lt;/code&gt; are stateless so they do not rely on high level components any more. Relationships between components are clear and simple.&lt;/p&gt;

&lt;p&gt;Tasks can be divided into the following parts:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/task.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are two types of tasks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Simple Task. Task that executes only once.&lt;/li&gt;
  &lt;li&gt;Period Task. Task that executes at every interval.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The result of task will convert to event and posts to the &lt;code class=&quot;highlighter-rouge&quot;&gt;EventManager&lt;/code&gt;. Any methods that subscribes that kind of event will be notified and execute the corresponding response, e.g. update the cache.&lt;/p&gt;

&lt;p&gt;Both the outside requests and chassis requests share the same interface of Configuration, they can implement their own way to load configurations. The difference between chassis requests and outside requests is that chassis requests need to manage microservice informations of their own. Besides,  chassis requests also need to provide a compatible interface for requests to use. There comes  to the component &lt;code class=&quot;highlighter-rouge&quot;&gt;RegistryUtils&lt;/code&gt;. It is responsible for the following stuff:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Initialize service registry client with configurations.&lt;/li&gt;
  &lt;li&gt;Initialization of service center service, attach with a PullTask.&lt;/li&gt;
  &lt;li&gt;Initialization of service itself, attach with RegisterTask, HeartbeatTask and WatchTask.&lt;/li&gt;
  &lt;li&gt;Provide wrapper method for service registry client.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The initialization process of service registry client is as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/client_initialization.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If the auto discovery switch is on, it need to create a period task &lt;code class=&quot;highlighter-rouge&quot;&gt;PullTask&lt;/code&gt; to make the available service center services’ information up to date.&lt;/p&gt;

&lt;p&gt;Any requests to a new microservice will create a new entry in the service registry client. Once we access the same microservice again, the client will response with the cached version which reduces communication cost with service center.&lt;/p&gt;

&lt;p&gt;Let’s checkout how the &lt;code class=&quot;highlighter-rouge&quot;&gt;Microservice&lt;/code&gt; component works. Instances and its versions are cached inside the microservice. To get an instance of a specified id, all it needs to do is lookup the cache or create a query task to update the cache. All interactions from &lt;code class=&quot;highlighter-rouge&quot;&gt;Microservice&lt;/code&gt; to  &lt;code class=&quot;highlighter-rouge&quot;&gt;ApiManager&lt;/code&gt; are done by the &lt;code class=&quot;highlighter-rouge&quot;&gt;Task&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ApiManager&lt;/code&gt; is designed to interact directly with service center as a pure client with api inside only. Its structure is as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/api_manager.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Eric Lee</name><email>eric.lee.ltk@gmail.com</email><uri>https://eric-lee-ltk.github.io</uri></author><category term="refactor" /><summary type="html">Analysis of service registry and propose a new architecture for it</summary></entry><entry xml:lang="cn"><title type="html">老司机带你刷任务 - ServiceComb JIRA入门指南</title><link href="/cn/docs/jira_beginner_guide/" rel="alternate" type="text/html" title="老司机带你刷任务 - ServiceComb JIRA入门指南" /><published>2017-11-16T00:00:00+08:00</published><updated>2017-11-16T11:43:00+08:00</updated><id>/cn/docs/jira-beginner-guide</id><content type="html" xml:base="/cn/docs/jira_beginner_guide/">&lt;p&gt;想参与社区贡献，却感觉老虎咬天，无从下口？不用担心，老司机带你一起刷新手任务！&lt;/p&gt;

&lt;p&gt;ServiceComb的所有任务托管在&lt;a href=&quot;https://servicecomb.atlassian.net&quot;&gt;ServiceComb JIRA&lt;/a&gt;上，
首先你需要&lt;a href=&quot;https://id.atlassian.com/signup?continue=https%3A%2F%2Fservicecomb.atlassian.net%2Flogin%3FredirectCount%3D1&quot;&gt;注册&lt;/a&gt;一个免费JIRA账户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.signup.png&quot; alt=&quot;jira sign up&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;登陆后请首先花几分钟上传自己的个性头像，让大家可以一眼看出哪些任务在你的掌控之下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.board.profile.png&quot; alt=&quot;jira profile&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来在菜单栏点击Boards，选择ServiceComb转到如下Kanban board。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.board.selection.png&quot; alt=&quot;jira board selection&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ServiceComb Kanban board页面分为三列：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;To Do：还未开始的任务&lt;/li&gt;
  &lt;li&gt;In Progress：进行中的任务&lt;/li&gt;
  &lt;li&gt;Done：已完成的任务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.board.png&quot; alt=&quot;jira board&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To Do列的任务卡上如果没有头像，代表这个任务无人领取，但作为新手，我怎么知道哪个任务容易上手呢？
我们很细心的为新手任务加上了绿色竖线标记，这个标记对应所有打了 &lt;code class=&quot;highlighter-rouge&quot;&gt;good-first-issue&lt;/code&gt; 标签的任务，
以便大家一眼识别，立即上手。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.good.first.issue.png&quot; alt=&quot;jira good first issue&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.story.png&quot; alt=&quot;jira story&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外，任务还按照功能模块划分了epic，这样大家可以在自己擅长的领域大显身手，或者在全新的模块挑战自己。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.epic.png&quot; alt=&quot;jira epic&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选到心仪的任务后，记得讲任务分配给自己，以免被别人抢走。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.story.assignment.png&quot; alt=&quot;jira story assignment&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外别忘了根据自己的进度，更新对应任务的状态，你可以直接拖动任务卡到对应状态列。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.status.update.png&quot; alt=&quot;jira status update&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，在完成任务后，咨询项目带队老司机，将自己的贡献添加到对应的发布版本中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.fix.version.png&quot; alt=&quot;jira fix.version&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看到现在相信你已经跃跃欲试，赶紧加入我们一起刷任务升级吧！&lt;/p&gt;</content><author><name>Sean Yin</name><email>seanyinx@gmail.com</email><uri>http://seanyinx.github.io</uri></author><summary type="html">ServiceComb JIRA入门指南</summary></entry><entry xml:lang="cn"><title type="html">Service-Center Management UI Console</title><link href="/docs/service-center-ui/" rel="alternate" type="text/html" title="Service-Center Management UI Console" /><published>2017-10-28T00:00:00+08:00</published><updated>2017-10-30T09:18:43+08:00</updated><id>/docs/service-center-ui</id><content type="html" xml:base="/docs/service-center-ui/">&lt;p&gt;Service-Center Management UI Console enables user to view the list of MicroServices registered in SC.
Users can view the detailed information of their MicroServices, Instances and Schemas.
Service-Center UI also offers a unique feature of testing the Schemas of their MicroServices from UI, Users 
can also download the html client for their Schemas.&lt;/p&gt;

&lt;h3 id=&quot;preview-of-management-console&quot;&gt;Preview of Management Console&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/Service-Center-UI-Preview.gif&quot; alt=&quot;Preview&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;features&quot;&gt;Features&lt;/h3&gt;
&lt;p&gt;Service-Center Management console offers very useful features which makes users easy to use and manage service-center.&lt;/p&gt;

&lt;h3 id=&quot;dashboard&quot;&gt;Dashboard&lt;/h3&gt;
&lt;p&gt;This is the place where you can get the overall information about the services which are registered in your service-center like total number of services, providers, consumers and total instances. You can also get a list of Services which based on their current status.&lt;br /&gt;
&lt;img src=&quot;/assets/images/Dashboard.PNG&quot; alt=&quot;Dashboard&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;micro-service-list&quot;&gt;Micro-Service List&lt;/h3&gt;
&lt;p&gt;This is the place where you can see the basic details of all the services which are registered in Service-Center. You can see the details like MicroService Name, Application Name, Status, Version, Creation time and Instance count. You can also un-register the microservice from Operations Tab if there is no running instances for the microservice.&lt;br /&gt;
&lt;img src=&quot;/assets/images/ServiceList.PNG&quot; alt=&quot;ServiceList&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;instance-details&quot;&gt;Instance Details&lt;/h3&gt;
&lt;p&gt;This is the place where you can see all the current running instances for the MicroService, you can get the list of endpoints and their protocols.&lt;br /&gt;
&lt;img src=&quot;/assets/images/InstanceList.PNG&quot; alt=&quot;InstanceList&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;provider-list&quot;&gt;Provider List&lt;/h3&gt;
&lt;p&gt;This is the place where you can get the list of all the providers for the MicroService.&lt;br /&gt;
&lt;img src=&quot;/assets/images/ProviderList.PNG&quot; alt=&quot;Provider List&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;consumer-list&quot;&gt;Consumer List&lt;/h3&gt;
&lt;p&gt;This is the place where you can get the list of all the consumers for the MicroService&lt;br /&gt;
&lt;img src=&quot;/assets/images/ConsumerList.PNG&quot; alt=&quot;Consumer List&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;schema-list&quot;&gt;Schema List&lt;/h3&gt;
&lt;p&gt;This is the place where we can get the list of all the Schema's for your MicroService, here you get options of viewing the Schema in Swagger form or Test the Schema on some particular instance. Here you also get an option to Download the Schema file in Html Client form.&lt;br /&gt;
&lt;img src=&quot;/assets/images/SchemaList.PNG&quot; alt=&quot;Schema List&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For Viewing the Schema in Swagger form you can click on Test Schema button and you can view the complete details of Schema in Swagger form.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/SchemaView.PNG&quot; alt=&quot;View Swagger&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you wish to test the Schema on some particular Instance then you can click on Test Schema and select the instance on which you want to test the Schema and then select the endpoints for that instance.&lt;br /&gt;
&lt;img src=&quot;/assets/images/SelectInstance.PNG&quot; alt=&quot;Select Instance&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once you selected the instance then you are ready for testing the Schema, you can input the required parameters for the Schema and hit on ‘Try it Out’ Button.&lt;br /&gt;
&lt;img src=&quot;/assets/images/Schematest.PNG&quot; alt=&quot;Schema Test&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;you-can-have-a-look-at-the-quick-start-guide-to-know-about-how-to-bring-up-the-management-console&quot;&gt;You can have a look at the &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-service-center/tree/master/frontend#quickstart-guide&quot;&gt;Quick Start Guide&lt;/a&gt; to know about how to bring up the Management Console.&lt;/h5&gt;</content><author><name>Asif Siddiqui</name><email>mohammad.asif.siddiqui1@huawei.com</email><uri>http://asifdxtreme.github.io</uri></author><category term="service center" /><summary type="html">An introduction Service-Center Management Console</summary></entry><entry xml:lang="en"><title type="html">Service-Center Management UI Console</title><link href="/docs/service-center-ui/" rel="alternate" type="text/html" title="Service-Center Management UI Console" /><published>2017-10-28T00:00:00+08:00</published><updated>2017-10-30T09:18:43+08:00</updated><id>/docs/service-center-ui</id><content type="html" xml:base="/docs/service-center-ui/">&lt;p&gt;Service-Center Management UI Console enables user to view the list of MicroServices registered in SC.
Users can view the detailed information of their MicroServices, Instances and Schemas.
Service-Center UI also offers a unique feature of testing the Schemas of their MicroServices from UI, Users 
can also download the html client for their Schemas.&lt;/p&gt;

&lt;h3 id=&quot;preview-of-management-console&quot;&gt;Preview of Management Console&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/Service-Center-UI-Preview.gif&quot; alt=&quot;Preview&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;features&quot;&gt;Features&lt;/h3&gt;
&lt;p&gt;Service-Center Management console offers very useful features which makes users easy to use and manage service-center.&lt;/p&gt;

&lt;h3 id=&quot;dashboard&quot;&gt;Dashboard&lt;/h3&gt;
&lt;p&gt;This is the place where you can get the overall information about the services which are registered in your service-center like total number of services, providers, consumers and total instances. You can also get a list of Services which based on their current status.&lt;br /&gt;
&lt;img src=&quot;/assets/images/Dashboard.PNG&quot; alt=&quot;Dashboard&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;micro-service-list&quot;&gt;Micro-Service List&lt;/h3&gt;
&lt;p&gt;This is the place where you can see the basic details of all the services which are registered in Service-Center. You can see the details like MicroService Name, Application Name, Status, Version, Creation time and Instance count. You can also un-register the microservice from Operations Tab if there is no running instances for the microservice.&lt;br /&gt;
&lt;img src=&quot;/assets/images/ServiceList.PNG&quot; alt=&quot;ServiceList&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;instance-details&quot;&gt;Instance Details&lt;/h3&gt;
&lt;p&gt;This is the place where you can see all the current running instances for the MicroService, you can get the list of endpoints and their protocols.&lt;br /&gt;
&lt;img src=&quot;/assets/images/InstanceList.PNG&quot; alt=&quot;InstanceList&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;provider-list&quot;&gt;Provider List&lt;/h3&gt;
&lt;p&gt;This is the place where you can get the list of all the providers for the MicroService.&lt;br /&gt;
&lt;img src=&quot;/assets/images/ProviderList.PNG&quot; alt=&quot;Provider List&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;consumer-list&quot;&gt;Consumer List&lt;/h3&gt;
&lt;p&gt;This is the place where you can get the list of all the consumers for the MicroService&lt;br /&gt;
&lt;img src=&quot;/assets/images/ConsumerList.PNG&quot; alt=&quot;Consumer List&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;schema-list&quot;&gt;Schema List&lt;/h3&gt;
&lt;p&gt;This is the place where we can get the list of all the Schema's for your MicroService, here you get options of viewing the Schema in Swagger form or Test the Schema on some particular instance. Here you also get an option to Download the Schema file in Html Client form.&lt;br /&gt;
&lt;img src=&quot;/assets/images/SchemaList.PNG&quot; alt=&quot;Schema List&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For Viewing the Schema in Swagger form you can click on Test Schema button and you can view the complete details of Schema in Swagger form.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/SchemaView.PNG&quot; alt=&quot;View Swagger&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you wish to test the Schema on some particular Instance then you can click on Test Schema and select the instance on which you want to test the Schema and then select the endpoints for that instance.&lt;br /&gt;
&lt;img src=&quot;/assets/images/SelectInstance.PNG&quot; alt=&quot;Select Instance&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once you selected the instance then you are ready for testing the Schema, you can input the required parameters for the Schema and hit on ‘Try it Out’ Button.&lt;br /&gt;
&lt;img src=&quot;/assets/images/Schematest.PNG&quot; alt=&quot;Schema Test&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;you-can-have-a-look-at-the-quick-start-guide-to-know-about-how-to-bring-up-the-management-console&quot;&gt;You can have a look at the &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-service-center/tree/master/frontend#quickstart-guide&quot;&gt;Quick Start Guide&lt;/a&gt; to know about how to bring up the Management Console.&lt;/h5&gt;</content><author><name>Asif Siddiqui</name><email>mohammad.asif.siddiqui1@huawei.com</email><uri>http://asifdxtreme.github.io</uri></author><category term="service center" /><summary type="html">An introduction Service-Center Management Console</summary></entry><entry xml:lang="cn"><title type="html">最头疼的遗留系统该如何改造？</title><link href="/cn/docs/how-to-reform-a-legacy-system/" rel="alternate" type="text/html" title="最头疼的遗留系统该如何改造？" /><published>2017-10-23T00:00:00+08:00</published><updated>2017-10-23T15:22:00+08:00</updated><id>/cn/docs/how-to-reform-a-legacy-system</id><content type="html" xml:base="/cn/docs/how-to-reform-a-legacy-system/">&lt;p&gt;随着RESTful、云计算、DevOps、持续交付等概念的深入人心，微服务（Microservices）逐渐成为系统架构的一个代名词。那么微服务是否是业界期待已久的架构解决方案？在对遗留系统进行微服务的改造过程中存在怎样的困难和挑战，应该注意些什么？在该分享中，王磊将通过实际的案例，跟大家探讨使用微服务改造遗留系统的实践之路。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;什么是微服务&lt;/li&gt;
  &lt;li&gt;微服务的诞生背景&lt;/li&gt;
  &lt;li&gt;遗留系统的微服务改造策略&lt;/li&gt;
  &lt;li&gt;微服务改造之路&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;什么是系统架构设计？&lt;/p&gt;

&lt;p&gt;一直以来，系统架构设计是IT领域经久不衰的话题之一，是每个系统构建过程中极其关键的一部分，它决定了系统是否能够被正确、有效的构建。架构师们也一直在持续探索，寻找更优秀的架构设计方式来构建系统。&lt;/p&gt;

&lt;p&gt;那什么是系统的架构设计？对于这个问题，我相信每个朋友都会有不同的定义，实际上，也并没有一个标准的答案来解释什么是架构设计。&lt;/p&gt;

&lt;p&gt;基于我过去的经验和工作方式，我认为系统架构设计的本质，是在应用系统内部找到这样一个动态平衡：平衡业务、技术、团队的同时，考虑系统灵活性、可扩展性以及可维护性等因素，并将应用系统划分成不同的部分，使这些部分彼此之间相互分工、相互协作，从而为用户提供某种特定的价值的方式。&lt;/p&gt;

&lt;p&gt;随着RESTful、云计算、DevOps、持续交付等概念的深入人心，&lt;strong&gt;微服务架构逐渐成为系统架构的一个代名词&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;什么是微服务架构&quot;&gt;什么是微服务架构&lt;/h2&gt;
&lt;p&gt;2015年，微服务架构这个词，以相当高的频率出现在各种演讲、文章、会议、社区上。这里，我先和大家快速回顾一下，Martin Fowler对微服务的抽象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/microservice_definition_by_martin_folwer.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上所示，微服务架构的核心四要素，我用红色标注出来了。如果翻译成中文，大致如下所示：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。 每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作（通常是基于HTTP协议的RESTful API）。 每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。 另外，对具体的服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结成一句话就是&lt;strong&gt;微服务是围绕业务构建的细粒度的分布式系统&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;微服务的诞生背景&quot;&gt;微服务的诞生背景&lt;/h2&gt;
&lt;p&gt;2015年，微服务突然火了，为什么？&lt;/p&gt;

&lt;p&gt;其实微服务架构并不是技术创新，而是IT发展到现阶段对技术架构的一种阐释。&lt;/p&gt;

&lt;p&gt;它要求包括&lt;strong&gt;快速和业务对齐（aligning business）、理解和抽象业务（基于领域建模）、快速开发（Lean、Agile）、快速反馈和交付（CI、CD、DevOps）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;所以说，微服务并不是技术，而是将化整为零（或称分治）思想换了一种说法，无论是把一个大型系统分割成多个小而自治的系统，还是把一个大型团队分成多个团队，或是把一个复杂的项目分成多个交付阶段都是这种思想的运用。&lt;/p&gt;

&lt;p&gt;当然，任何新事物的诞生，总会有一个推动因素。微服务的诞生也并非偶然。它是互联网高速发展，技术日新月异的变化以及传统架构无法适应快速变化等多重因素的推动下所诞生的产物。&lt;/p&gt;

&lt;p&gt;基于个人的理解，我将微服务的诞生因素总结为如下几点：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/why_microservice_show_up.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;互联网行业的快速发展&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;过去的十年中，互联网对我们的生活产生了翻天覆地的变化，越来越多的传统行业公司也开始依赖互联网技术打造其核心竞争优势。&lt;/p&gt;

    &lt;p&gt;在这种情况下，如何从系统架构的角度出发，构建灵活、易扩展的系统，快速应对需求的变化；同时，随着用户量的增加，如何保证系统的可伸缩性、高可用性，成为系统架构面临的挑战。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;单块架构系统面临的挑战&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;随着用户需求个性化、产品生命周期变短、市场需求不稳定等因素的出现，单块架构系统面临着越来越多的挑战。如何找到一种更有效的、更灵活、适应需求的系统架构方式，成为大家关注的焦点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;敏捷、精益方法、持续交付的深入人心&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;在IT行业发展的过去十年，敏捷、精益、持续交付等价值观、方法论的提出以及实践，让很多组织意识到应变市场变化、提高响应力的重要性，应该构建软件交付周期的闭环（分析、开发、测试、部署、运维、监控、运营），而不仅仅是提高开发阶段的效率。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;精益创业（Lean Startup）&lt;/strong&gt;帮助组织分析并建立最小可实行产品（MinimumViableProduct），通过迭代持续改进敏捷方法帮助组织消除浪费，通过反馈不断找到正确的方向。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;持续交付&lt;/strong&gt;则帮助组织构建更快、更可靠、可频繁发布的交付机制并构建产品交付闭环。&lt;/p&gt;

    &lt;p&gt;大部分组织已经基本上形成了一套可实施的交付体系。包括持续集成、自动化测试、数据管理、自动化部署机制等。&lt;/p&gt;

    &lt;p&gt;这时候，大泥球式的单块架构，会逐渐成为影响交付周期进一步优化的瓶颈，因此如何找到灵活性高、扩展性好的架构方式，也成为进一步优化交付周期面临的挑战。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Docker等容器虚拟化技术的快速发展&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;同传统的虚拟化技术相比，基于容器技术的Docker，不需要复杂的Hypervisor机制支持，具有更高的虚拟化性能和效率。&lt;/p&gt;

    &lt;p&gt;同时容器可以很容易的运行在任意的装有DockerEngine的系统上，使得开发人员能够用更低的成本将应用程序部署在不同平台上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DevOps文化&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;DevOps文化的推行打破了传统开发与运维之间的壁垒，帮助组织形成开发、运维紧密配合的、全功能化的高效团队，并尽早降低软件交付最后一公里的风险。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;遗留系统的微服务改造策略&quot;&gt;遗留系统的微服务改造策略&lt;/h2&gt;
&lt;p&gt;聊完什么是微服务架构以及其诞生背景，接下来我们来谈谈如何改造遗留系统。&lt;/p&gt;

&lt;p&gt;在过去的10多年间，大部分工作时间我都在和遗留系统打交道。我相信很多朋友也是工作在已经运转多年的遗留系统上。&lt;/p&gt;

&lt;p&gt;对于这类系统，当谈论使用微服务对其进行改造时，我认为要谨记一点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;改造不是重做。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在改造的过程中，要始终以保证系统为用户提供的业务价值可用作为首要目标。&lt;/strong&gt;从这个点出发，基于我的经验，对微服务改造的策略总结为如下五个步骤：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/microservice_reform_strategy.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;范围定义&lt;/p&gt;

    &lt;p&gt;对于遗留系统而言，通常业务运转时间较长（譬如5~8年以上，甚至更长），因此涉及的功能繁杂，代码中存在大量无效或者过时的需求，缺陷修复成本较高。&lt;/p&gt;

    &lt;p&gt;另外，系统在演进的过程中，也会持续为用户提供新的功能和价值。因此，划分出清晰的范围非常重要。&lt;/p&gt;

    &lt;p&gt;实际上，范围定义主要包括两部分：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;明确业务改造范围&lt;/p&gt;

        &lt;p&gt;所谓改造范围，就是确定我们常说的业务试点。通常，作为初次尝试微服务实践的组织，建议选取业务范围影响较小、非关键功能的试点，这样做也是为了确保在不影响核心业务的情况下快速尝试并获得反馈。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;明确成员责任范围&lt;/p&gt;

        &lt;p&gt;明确成员责任范围，确定由谁来改造，确保改造的目标清晰。&lt;/p&gt;

        &lt;p&gt;实际上，对于产品而言，遗留系统的维护和更新，包括缺陷定位、缺陷修复、数据更新、功能实现、测试、交付给运维团队等，通常已经让团队的工作处于高负荷状态。因此，需要确定成员，全身心的投入，以微服务改造作为短期目标。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;功能剥离&lt;/p&gt;

    &lt;p&gt;有了明确的业务范围，成员也有了清晰的责任，接下来就需要将部分功能点进行剥离。&lt;/p&gt;

    &lt;p&gt;所谓剥离，就是将选中的功能从原有的系统中拆分出来，并构建成独立的服务。在这个阶段，主要包括两点：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;将功能从原有系统拆分出来，并构建新服务&lt;/p&gt;

        &lt;p&gt;一提到拆分，很多朋友会纠结，“系统复杂，如何拆分微服务才好？怎么样的拆分才合理？”。其实，从我个人的观点来看，这时候还不是纠结服务到底怎么划分合理的时候。为什么？&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;好的架构是动态演变和迭代出来的，业务在不断改变，技术和工具也在不会的升级换代，没有完美的架构，只有无限逼近完美的动态平衡，所以先小范围、低成本动起来，在运转中找平衡点。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;微服务的复杂度在于分布式系统本身，以及其生态系统（开发、测试、部署、运维、监控、告警）的搭建。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;团队文化的形成是一个相对漫长的过程，如果花很大力气关注服务怎么拆，而没有聚焦在生态系统的搭建以及团队文化的形成上，实际上是舍本逐末。即便拆分出了不同的服务，在落地的时候也会遇到诸多问题。所以，找一个功能点先拆，然后搭建持续交付流水线，快速试错，建立好有效的反馈闭环机制，再不断寻找动态平衡，拆分出更细的服务或者将不合理的服务合并。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在原有的系统前端，使用代理机制，并使用遗留系统和新服务组合为用户提供价值&lt;/p&gt;

        &lt;p&gt;这一步，目的是使用组合的系统（遗留系统+新的服务）为用户提供价值。&lt;/p&gt;

        &lt;p&gt;对于Web系统，通常可以在前端使用直接请求新的服务。也可以在后端使用转发请求，获取新服务提供的数据。&lt;/p&gt;

        &lt;p&gt;如下图所示：&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/microservice_reform_strategy.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据解耦&lt;/p&gt;

    &lt;p&gt;在以前的遗留系统构建过程中，通常使用数据库作为集成点，不同功能/系统之间通过数据库完成数据交换。对于某些系统，还大量使用存储过程完成业务逻辑，开发的时候看似效率高，但几年下来，DBA成了IT团队最懂业务的人，维护成为瓶颈。&lt;/p&gt;

    &lt;p&gt;而实际上，业务的数据是业务固有的组成部分，应当随着业务的变化而变化。业务拆分出来，数据也应该拆分出来。从而保证访问数据只能通过统一的相关业务API完成。便于在将来的业务和架构演进中，有效的对数据维护、管理和升级。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据同步&lt;/p&gt;

    &lt;p&gt;数据同步，是一个价值体现的过渡过程。&lt;/p&gt;

    &lt;p&gt;一方面，遗留系统的改造中存在的各种各样的挑战和我们今天认为的不合理（当时的场景也许是合理的）。另一方面，对于大部分遗留的系统，都会使用数据库作为集成点（开发成本低），导致某业务功能的数据与其他功能有着千丝万缕的联系，数据的变化容易对其他功能造成影响。&lt;/p&gt;

    &lt;p&gt;因此对于大型的遗留系统，很难在短期的时间内（3~6个月）完成全系统的改造。需要一个相对漫长，循序渐进的过程来完成改造。&lt;/p&gt;

    &lt;p&gt;譬如，在电商系统中，商家的后台管理系统中的产品、价格的更新，会发布到面向用户的电商搜索系统中以及其他系统中。如果我们将系统中的产品相关拆分成独立服务，则必须也要拆分数据发布机制，否则的话容易造成数据不一致。但拆分数据发布机制，又需要分析清楚不同数据之间的影响和依赖，需要更大的成本，短期内不易完成。&lt;/p&gt;

    &lt;p&gt;这时候，如果将新服务的数据同步回原有的数据库，采用这样一个折中的的过程，既能保障新的服务和数据被独立，又不影响原有的遗留系统功能。&lt;/p&gt;

    &lt;p&gt;说白了，这其实也是在保证系统为用户提供的业务价值不被破坏。&lt;/p&gt;

    &lt;p&gt;有了之前的尝试，接下来就是通过不断的迭代，完成功能剥离，数据解耦、数据同步，从而将更多的功能拆分成独立的服务。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/legacy_system_reform_strategy.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上就是我对于遗留系统改造的策略。&lt;/p&gt;

&lt;h2 id=&quot;遗留系统改造实践&quot;&gt;遗留系统改造实践&lt;/h2&gt;
&lt;p&gt;接下来，我和大家分享一个我所经历的遗留系统改造的案例。首先，让我们看看这个系统的背景和一些数据。&lt;/p&gt;

&lt;h3 id=&quot;客户背景&quot;&gt;客户背景&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://movit-tech.com/&quot;&gt;盟拓软件&lt;/a&gt;是中国房地产行业IT服务及行业解决方案和产品的领先厂家，其依据市场变化推出全民卖房的新营销模式，正从线下的传统现场售楼模式向线上的房地产电商模式进行转变。&lt;/p&gt;

&lt;h3 id=&quot;业务痛点&quot;&gt;业务痛点&lt;/h3&gt;

&lt;p&gt;当今房地产行业呈现短期开盘峰值、后期零星散客的业务特性。其面临着高昂线下运营成本，营销成本占销售额&amp;gt;5%。而由此引入的线上竞价秒杀营销模式，传统IT解决方案的系统资源率、峰值扩容能力将无法满足。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/case_mengtuo_traditional_mode.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;系统概览&quot;&gt;系统概览&lt;/h3&gt;

&lt;p&gt;系统为典型的三层单块架构，使用MySQL数据库存储数据。运行在服务器上的应用处理性能较低，为了应对短暂的访问高峰，额外购置了较多的服务器资源，访问高峰过后，服务器资源闲置造成较大浪费，且需要较多人员维护。&lt;/p&gt;

&lt;h3 id=&quot;相关数据&quot;&gt;相关数据&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;代码约&lt;strong&gt;100万&lt;/strong&gt;行，测试覆盖率为&lt;strong&gt;10%&lt;/strong&gt;，集成测试时间为&lt;strong&gt;一个月&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;代码臃肿，无效遗留代码较多，且业务间紧耦合，测试覆盖率较低，测试出问题了难以定位，导致测试耗时较长。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;营销预案需&lt;strong&gt;提前1个月&lt;/strong&gt;准备资源&lt;/p&gt;

    &lt;p&gt;为应对访问高峰，每次都需要预购大量的服务资源，重新部署环境，并运行相关测试。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;业务耦合紧，新业务上线&lt;strong&gt;&amp;gt;半年&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;每次测试都要多个业务团队联合测试，问题定位较耗时，测试效率低。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;上百种业务，2-3种开发语言&lt;/p&gt;

    &lt;p&gt;业务复杂，且语言不一，系统联调时耗时较多且需相互配合，时间周期较长。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运维团队&lt;strong&gt;&amp;gt;20人&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;臃肿的团队导致问题定位需多方配合，沟通成本高。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;基于之前定义的改造策略，我们的改造过程大致如下所示：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;范围定义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将原房地产CRM平台按业务类别拆分为多个微服务。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/case_mengtuo_reform_before_and_after.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;功能剥离：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从单体CRM系统中逐步拆分出业务模块（服务网关、客户服务、房源服务、机会服务、积分服务）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据解耦&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个微服务的数据进行独立存储。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据同步&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在负载较低时，将数据同步回原有的遗留系统中不断迭代，陆续完成后续的服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改造过程中，基于ServiceComb，&lt;strong&gt;通过控制请求路由，逐步架空对原单体应用的请求， 平滑过渡系统到微服务架构。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单个服务的构建并没有那么复杂，基于ServiceComb，通过如下的简单4步，即可快速完成改造：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;引入&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis&quot;&gt;ServiceComb Java Chassis&lt;/a&gt;框架依赖&lt;/li&gt;
  &lt;li&gt;定义服务接口端点&lt;/li&gt;
  &lt;li&gt;添加服务配置文件&lt;/li&gt;
  &lt;li&gt;注释服务启动入口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，通过Company Workshop中提供的Docker插件配置，10分钟内完成了服务容器化，自动生成镜像。&lt;/p&gt;

&lt;p&gt;同时，利用ServiceComb开发的微服务应用，可同时无缝接入&lt;a href=&quot;https://www.huaweicloud.com/product/servicestage.html&quot;&gt;ServiceStage&lt;/a&gt;，享受到微服务治理、容器虚机混编、应用拓扑等能力。&lt;/p&gt;

&lt;p&gt;为应对短暂的业务高峰，经常需要预购大量的资源来提前部署和验证环境，花费大量的人力物力，且资源利用率极低。因此，进行云化改造后的产品和解决方案需要具备随着参与人数增加而秒级伸缩，支撑业务峰值和资源利用率的能力。盟拓软件基于华为ServiceStage的核心技术容器改造、混编方案、编排调度算法等进行容器虚机混编应用云化改造，实现了应用的秒级部署和弹性伸缩能力，极大地提高了资源的利用率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;改造后效果：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;运维人力&lt;strong&gt;减少80%&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;资源利用率&lt;strong&gt;提升50%&lt;/strong&gt;，大幅降低运营成本&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;每秒万级&lt;/strong&gt;调用链分析能力&lt;/li&gt;
  &lt;li&gt;传统系统和应用平滑改造上云&lt;/li&gt;
  &lt;li&gt;互联网营销模式，天粒度业务快速创新&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/case_mengtuo_new_mode.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理论上，经过不断地迭代，逐渐完成业务功能解耦，新服务构建。那么遗留系统就会被替换掉。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;改造要点&quot;&gt;改造要点&lt;/h2&gt;
&lt;p&gt;在改造的整个过程中，我认为如下几个实践是非常重要的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/best_practices_for_legacy_system_reform.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;基础设施自动化&quot;&gt;基础设施自动化&lt;/h3&gt;
&lt;p&gt;原有的部署发生在数据中心，因此流程上相对复杂，而且存在一定弊端（譬如审批和协作上，起不到实质作用）。对于改造后的服务而言，我们使用更多的自动化方式代替复杂的审批流程。通过使用华为ServiceStage作为基础设施，团队能够更自主的对基础设施进行管理。如资源创建、销毁、更新等。随着服务的增多，基础设施自动化帮助我们节省了大量的时间。当然，从组织层面，也成立了专门的小组研究华为ServiceStage以及相关的DevOps配套工具。&lt;/p&gt;

&lt;p&gt;目前，国内外有很多优秀的云平台，可以方便的为用户提供基础设施的自动化机制。&lt;/p&gt;

&lt;h3 id=&quot;微服务生态系统&quot;&gt;微服务生态系统&lt;/h3&gt;
&lt;p&gt;微服务的生态系统是指微服务实施过程相关的协作部分，涉及部分较多，譬如测试机制、持续集成、自动化部署、细粒度监控、日志聚合、告警、持续交付，以及大家非常关注的服务注册、服务发现机制等。&lt;/p&gt;

&lt;p&gt;这部分的灵活性比较大，因为目前如上说的每一个领域都有很多优秀的工具。譬如日志聚合目前业界的方案通常为ELK，监控的方案如Zabbix、NewRelic、CloudWatch等，成熟的监控工具都具有告警功能，PagerDuty也提供更专业的告警服务。服务注册和发现有ServiceComb框架的Service Center，Eureka，Consul，Zookeeper。大家可以在各自的团队中自由发挥。&lt;/p&gt;

&lt;h3 id=&quot;开发框架的演进&quot;&gt;开发框架的演进&lt;/h3&gt;
&lt;p&gt;开发框架是团队在构建微服务的过程中，不断总结，梳理出的快速开发微服务的相关工具和框架。&lt;/p&gt;

&lt;p&gt;我们基于ServiceComb构建了快速开发框架，主要包括四部分，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/rapid_development_framework.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;微服务工程示例&lt;/p&gt;

    &lt;p&gt;提供微服务改造架构最佳实践参考工程Company，使能微服务改造或开发能复用其架构设计和配置，同时指导实现服务容器化和后续服务性能测试等提高服务可靠性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;契约生成工具&lt;/p&gt;

    &lt;p&gt;ServiceComb采用了基于OpenAPI的服务契约，使业务逻辑与编程语言解耦，并可使用Swagger工具定义服务契约，自动生成契约对应的代码和文档。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;持续集成&lt;/p&gt;

    &lt;p&gt;持续集成使用了Jenkins，通过其配置文件定义主要的阶段：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;验证：运行单元测试，集成测试&lt;/p&gt;

      &lt;p&gt;构建：构建可执行的jar部署包&lt;/p&gt;

      &lt;p&gt;部署：基于指定版本制作镜像，并推送到测试或生产环境下&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;利用这样的持续集成模板工程，花费很少的时间，就可以针对新建的微服务应用，快速配置其对应的持续集成环境。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kubernetes集群一键部署&lt;/p&gt;

    &lt;p&gt;Kubernetes是谷歌开源的一个容器集群管理工具。基于Kubernetes，可实现微服务的快速部署及弹性伸缩。我们提供了一键部署脚本，部署时只需稍作修改即可通过一条命令，自动完成资源的创建、部署、弹性伸缩、金丝雀发布等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;团队运维自管理&quot;&gt;团队运维自管理&lt;/h3&gt;

&lt;p&gt;这一部分是关于团队的文化管理。也是对DevOPS的延伸，我们称为TMI（Team Managed Infrastructure）。&lt;/p&gt;

&lt;p&gt;目的是将分析、开发、测试以及资源创建、销毁、自动化部署的权利交给团队，由团队按需完成部署（加上看板的流程管理，而非Scrum的固定迭代，可以做到一天部署多次）。&lt;/p&gt;

&lt;p&gt;当然，这个环节非常依赖于成熟的监控以及告警机制，当出现问题时，能够有效的通知到责任人，快速反馈，快速修复。团队内部也会定期轮换Pager（出问题救火的人），培养团队以服务可用作为大家的共同目标，培养产品观念，而非项目观念。&lt;/p&gt;

&lt;p&gt;再回顾一下这个图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/best_practices_for_legacy_system_reform.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，和大家分享一下，我个人在微服务实施过程中总结的4句方针:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由大到小，由粗到细&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关注运维，关注监控&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;快速反馈，快速修复&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;循序渐进，增量实现&lt;/strong&gt;&lt;/p&gt;</content><author><name>Wang Lei</name><email>wanglei177@huawei.com</email><uri>https://wldandan.github.io</uri></author><category term="系统改造" /><summary type="html">微服务是否是业界期待已久的企业架构解决方案？在对遗留系统进行微服务的改造过程中存在怎样的困难和挑战，应该注意些什么？</summary></entry></feed>