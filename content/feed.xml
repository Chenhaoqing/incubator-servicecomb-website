<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-05-08T11:02:05+08:00</updated><id>/</id><title type="html">Apache ServiceComb (incubating)</title><subtitle>The homepage of ServiceComb</subtitle><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;&quot;/assets/images/ServiceComb-logo-3.jpg&quot;, &quot;bio&quot;=&gt;&quot;ServiceComb is a microservice framework that provides service registration, discovery, configuration and management utilities.&quot;, &quot;biocn&quot;=&gt;&quot;ServiceComb提供了一套关于服务注册，服务发现，服务配置以及管理功能的微服务框架&quot;, &quot;location&quot;=&gt;&quot;China&quot;, &quot;locationcn&quot;=&gt;&quot;中国&quot;, &quot;email&quot;=&gt;&quot;servicecomb-developers@googlegroups.com&quot;, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;&quot;ServiceComb&quot;, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil}</name><email>servicecomb-developers@googlegroups.com</email></author><entry xml:lang="cn"><title type="html">ServiceComb Saga使用Cucumber做验收测试源码分析</title><link href="/cn/docs/saga_with_cucumber/" rel="alternate" type="text/html" title="ServiceComb Saga使用Cucumber做验收测试源码分析" /><published>2018-04-28T00:00:00+08:00</published><updated>2018-04-27T19:05:00+08:00</updated><id>/cn/docs/saga_with_cucumber</id><content type="html" xml:base="/cn/docs/saga_with_cucumber/">&lt;h3 id=&quot;servicecomb-saga使用cucumber做验收测试源码分析&quot;&gt;ServiceComb Saga使用Cucumber做验收测试源码分析&lt;/h3&gt;

&lt;h4 id=&quot;cucumber-简介&quot;&gt;Cucumber 简介&lt;/h4&gt;

&lt;p&gt;Cucumber 是一个能够理解用普通语言描述的测试用例的自动化测试工具，可以让人们用近似自然的语言去描述特性Feature和场景Scenario，根据Feature驱动开发，用作软件技术人员和非技术之间验收测试的桥梁。它是一个命令行工具，运行后会执行features中的内容，feature中的step会调用step definitions 可以用标签来组织场景支持40多种语言包括 Java, Ruby 等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/cucumber.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Cucumber开发过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建feature文件，feature文件中描述了测试用例集（Features），测试用例(Scenarios)，创建测试所需环境(Given)，触发被测试事件(When)和结果验证(Then)&lt;/li&gt;
  &lt;li&gt;创建step_definitions，此代码根据上面创建的feature文件，映射feature中的Gherkin Step为按步骤执行的代码，类似胶水的作用。&lt;/li&gt;
  &lt;li&gt;执行cucumber执行指令，格式化输出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多关于Cucumber的介绍请参考&lt;a href=&quot;https://cucumber.io/&quot;&gt;官网文档[2]&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;saga-使用-cucumber&quot;&gt;Saga 使用 Cucumber&lt;/h4&gt;

&lt;p&gt;Saga项目对其下行程预定demo做了验收测试，我们对照Cucumber的开发过程分别分析成功执行完所有事务和出现异常时的自动化测试开发，在行程预定的demo中，全局事务&lt;code class=&quot;highlighter-rouge&quot;&gt;booking&lt;/code&gt;有两个子事务分别是预定酒店服务&lt;code class=&quot;highlighter-rouge&quot;&gt;Hotel&lt;/code&gt;和包车服务&lt;code class=&quot;highlighter-rouge&quot;&gt;Car&lt;/code&gt;，只有酒店服务和包车服务全部成功行程预定服务才算成功，否则全部失败并回滚补偿。demo中假定了房源紧张，每个用户最多只能预定2间，关于此行程规划demo细节请参考&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-saga/tree/master/saga-demo/booking&quot;&gt;文档[3]&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;成功完成所有事务&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;创建feature文件&lt;code class=&quot;highlighter-rouge&quot;&gt;pack_success_scenario.feature&lt;/code&gt;，定义Feature，并在feature中定义step&lt;/p&gt;

        &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Feature: Alpha records transaction events

  Scenario: Everything is normal
    Given Car Service is up and running
    And Hotel Service is up and running
    And Booking Service is up and running
    And Alpha is up and running

    When User Sean requests to book 2 cars and 1 rooms

    Then Alpha records the following events
      | serviceName  | &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;             |
      | pack-booking | SagaStartedEvent |
      | pack-car     | TxStartedEvent   |
      | pack-car     | TxEndedEvent     |
      | pack-hotel   | TxStartedEvent   |
      | pack-hotel   | TxEndedEvent     |
      | pack-booking | SagaEndedEvent   |

    And Car Service contains the following booking orders
      | name | amount | confirmed | cancelled |
      | Sean | 2      | &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;      | &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;     |

    And Hotel Service contains the following booking orders
      | name | amount | confirmed | cancelled |
      | Sean | 1      | &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;      | &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;     |
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Given&lt;/code&gt; 定义了测试用例&lt;code class=&quot;highlighter-rouge&quot;&gt;Everything is normal&lt;/code&gt;所需的4个条件分别是4个服务运行正常，&lt;code class=&quot;highlighter-rouge&quot;&gt;When&lt;/code&gt;定义了触发用户&lt;code class=&quot;highlighter-rouge&quot;&gt;Sean&lt;/code&gt;发起预定2辆车和1间房子的被测事件。&lt;code class=&quot;highlighter-rouge&quot;&gt;Then&lt;/code&gt;中则指定了验证结果是&lt;code class=&quot;highlighter-rouge&quot;&gt;Alpha&lt;/code&gt;记录的各子事务及子事务发生顺序，&lt;code class=&quot;highlighter-rouge&quot;&gt;Car&lt;/code&gt;服务和&lt;code class=&quot;highlighter-rouge&quot;&gt;Hotel&lt;/code&gt;服务则记录预定结果。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;创建step_definitions &lt;code class=&quot;highlighter-rouge&quot;&gt;PackStepdefs.java&lt;/code&gt;&lt;/p&gt;

        &lt;p&gt;在step_definition中使用正则的方式对应feature中定义的的测试条件，触发测试并验证结果。如：&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;Given&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;^Car Service is up and running$&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;probe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAR_SERVICE_ADDRESS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;上面代码对应feature中第一个测试前提条件&lt;code class=&quot;highlighter-rouge&quot;&gt;Given car service is up and running&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;probe&lt;/code&gt;函数式方位&lt;code class=&quot;highlighter-rouge&quot;&gt;Car&lt;/code&gt;服务的一个Rest接口验证返回状态码来判断&lt;code class=&quot;highlighter-rouge&quot;&gt;Car&lt;/code&gt;是否正常启动运行。接下来四个&lt;code class=&quot;highlighter-rouge&quot;&gt;Given&lt;/code&gt;与此类似。&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;When&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;^User ([A-Za-z]+) requests to book ([0-9]+) cars and ([0-9]+) rooms$&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rooms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Received request from user {} to book {} cars and {} rooms&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rooms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pathParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pathParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rooms&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rooms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pathParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cars&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;booking.service.address&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/booking/{name}/{rooms}/{cars}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;此段代码解析feature中定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;When User Sean requests to book 2 cars and 1 rooms&lt;/code&gt;事件，解析出用户、预定车辆和房间数量参数并向&lt;code class=&quot;highlighter-rouge&quot;&gt;Booking&lt;/code&gt;服务发出&lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt;方法的请求，然后在下面代码的&lt;code class=&quot;highlighter-rouge&quot;&gt;Then&lt;/code&gt;中验证结果：&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Then&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;^Alpha records the following events$&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataTable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;columnStrippingConsumer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;keySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;retainAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;topCells&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;dataMatches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ALPHA_REST_ADDRESS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/events&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;columnStrippingConsumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;And&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;^Car Service contains the following booking orders$&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataTable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;dataMatches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAR_SERVICE_ADDRESS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/bookings&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_OP_CONSUMER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;And&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;^Hotel Service contains the following booking orders$&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataTable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;dataMatches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HOTEL_SERVICE_ADDRESS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/bookings&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_OP_CONSUMER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;上面代码对应feature中&lt;code class=&quot;highlighter-rouge&quot;&gt;Then&lt;/code&gt;结果从三方面验证预定事件是否符合预期：&lt;code class=&quot;highlighter-rouge&quot;&gt;Alpha&lt;/code&gt;服务中记录的事件顺序、&lt;code class=&quot;highlighter-rouge&quot;&gt;Car&lt;/code&gt;服务的预定结果和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hotel&lt;/code&gt;服务中的预定结果。&lt;code class=&quot;highlighter-rouge&quot;&gt;DataTable&lt;/code&gt;解析了feature中定义的事件结果和顺序，&lt;code class=&quot;highlighter-rouge&quot;&gt;dataMatches&lt;/code&gt;将此结果与各服务中查询到的结果进行比较验证是不是符合预期。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;执行Command &lt;code class=&quot;highlighter-rouge&quot;&gt;RunCucumberIT.java&lt;/code&gt;&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@Runwith(Cucumber.class)&lt;/code&gt;指定使用Cucumber测试框架入口，并在&lt;code class=&quot;highlighter-rouge&quot;&gt;@CucumberOptions&lt;/code&gt;中指定feature目录和输出格式。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有子事务出现异常测试&lt;/p&gt;

    &lt;p&gt;由于房源紧张，限制每个用户最多预订2间房，当用户预订超过2间时会抛出异常：&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Compensable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compensationMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cancel&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HotelBooking&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;booking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;booking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;can not order the rooms large than two&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;booking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;confirm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bookings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;booking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;booking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在此异常测试中我们预订事件中预订3间房，由于订房间失败，整个行程事务没有成功，对已经成功执行的订车子事务进行补偿保证原子性。&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;创建feature文件&lt;code class=&quot;highlighter-rouge&quot;&gt;pack_compensation_scenario.feature&lt;/code&gt;&lt;/p&gt;

        &lt;p&gt;与成功的行程规划测试中不同的只有触发的预定事件和最终的结果，前提条件都是4个服务启动并运行，所以feature只要修改&lt;code class=&quot;highlighter-rouge&quot;&gt;When&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Then&lt;/code&gt;内容即可（Features和Scenarios名也要对应修改）&lt;/p&gt;

        &lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;s&quot;&gt;When User Sean requests to book 5 cars and 3 rooms&lt;/span&gt;

    &lt;span class=&quot;s&quot;&gt;Then Alpha records the following events&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| serviceName  | type               |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-booking | SagaStartedEvent   |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-car     | TxStartedEvent     |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-car     | TxEndedEvent       |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-hotel   | TxStartedEvent     |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-hotel   | TxAbortedEvent     |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-car     | TxCompensatedEvent |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-car     | SagaEndedEvent     |&lt;/span&gt;

    &lt;span class=&quot;s&quot;&gt;Then Car Service contains the following booking orders&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| name | amount | confirmed | cancelled |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| Sean | 5      | false     | true      |&lt;/span&gt;

    &lt;span class=&quot;s&quot;&gt;Then Hotel Service contains the following booking orders&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| name | amount | confirmed | cancelled |&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;step_definition和Command与之前一样，不需要任何修改，触发预定超过3个房间的操作后，&lt;code class=&quot;highlighter-rouge&quot;&gt;Alpha&lt;/code&gt;会记录Hotel服务的&lt;code class=&quot;highlighter-rouge&quot;&gt;TxAbortedEvent&lt;/code&gt;和Car服务的&lt;code class=&quot;highlighter-rouge&quot;&gt;TxCompensatedEvent&lt;/code&gt;时间，此外Car服务的预定记录中会有取消为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;的记录。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;通过以上两个例子分析，Cucumber开发只需要在feature中定义好测试所需条件，触发事件和结果验证信息，然后在step_definition中进行解析验证即可。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;byteman-规则注入&quot;&gt;Byteman 规则注入&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Byteman&lt;/code&gt;可以在代码的任意位置注入代码，并可以在注入的代码中访问当前方法中变量，包括方法参数、局部变量、调用其他函数的参数值、返回值等。更多关于Byteman的介绍请参考&lt;a href=&quot;http://byteman.jboss.org/docs.html&quot;&gt;官方文档[4]&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Byteman开发过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建规则脚本.btm文件&lt;/p&gt;

    &lt;p&gt;根据byteman语法创建规则，包括规则名，目标类，目标方法，注入位置，注入内容等，下面是一个在&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数入口注入打印语句的规则文件例子&lt;/p&gt;

    &lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;RULE trace main entry&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;CLASS AppMain&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;METHOD main&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;AT ENTRY&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;IF true&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;DO traceln(&quot;entering main&quot;)&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;ENDRULE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在安装了byteman环境的机器上用javaagent参数指定加载规则文件运行AppMain即可在main函数入口处打印出&lt;code class=&quot;highlighter-rouge&quot;&gt;entering main&lt;/code&gt;。例子&lt;a href=&quot;https://github.com/adinn/byteman-tutorial1&quot;&gt;源码请参考[5]&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加载规则并运行&lt;/p&gt;

    &lt;p&gt;除了上面例子中通过命令行指定javaagent指定byteman 规则文件的加载方式外，还可以通过Java代码的方式加载，如下&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Submit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addRulesFromFiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;org.jboss.byteman.agent.submit.Submit&lt;/code&gt;提供的加载规则的方法有通过文件加载&lt;code class=&quot;highlighter-rouge&quot;&gt;addRulesFromFiles&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;addRulesFromResources&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;同样，byteman提供了移除规则的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;deleteRulesFromFiles&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;deleteRulesFromResources&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;deleteAllRules&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;saga-使用-cucumber-集成-byteman&quot;&gt;Saga 使用 Cucumber 集成 Byteman&lt;/h4&gt;

&lt;p&gt;Saga在Cucumber中集成了byteman注入一个超时异常，测试Saga对超时处理是否符合预期。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建byteman规则文件：&lt;code class=&quot;highlighter-rouge&quot;&gt;booking_timeout.btm&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;RULE set the saga timeout to 5s&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;INTERFACE org.apache.servicecomb.saga.omega.context.annotations.SagaStart&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;METHOD timeout&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;AT EXIT&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;IF TRUE&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;DO RETURN 5&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;ENDRULE&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;RULE sleep when postBooking until timeout happens&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;CLASS org.apache.servicecomb.saga.demo.pack.booking.BookingController&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;METHOD postBooking&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;AT ENTRY&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;IF TRUE&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;DO debug(&quot;delay 10s until the booking timeout&quot;),&lt;/span&gt;
   &lt;span class=&quot;s&quot;&gt;Thread.sleep(10000)&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;ENDRULE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;这里定义了两个规则，第一个规则&lt;code class=&quot;highlighter-rouge&quot;&gt;set the saga timeout to 5s&lt;/code&gt;在注解&lt;code class=&quot;highlighter-rouge&quot;&gt;@SagaStart&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt;方法中返回5表示设置超时时间值为5秒。第二个规则&lt;code class=&quot;highlighter-rouge&quot;&gt;sleep when postBooking until timeout happens&lt;/code&gt;在类&lt;code class=&quot;highlighter-rouge&quot;&gt;BookingController&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;postBooking&lt;/code&gt;方法中注入&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.sleep(10000)&lt;/code&gt;，让&lt;code class=&quot;highlighter-rouge&quot;&gt;postBooking&lt;/code&gt;方法阻塞10秒，原来的&lt;code class=&quot;highlighter-rouge&quot;&gt;postBooking&lt;/code&gt;方法是一个空方法，注入byteman的阻塞方法后会触发预定行程服务的超时异常。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建feature文件：&lt;code class=&quot;highlighter-rouge&quot;&gt;pack_timeout_scenario.feature&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt; 	&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Given Install the byteman script booking_timeout.btm to Booking Service&lt;/span&gt;

    &lt;span class=&quot;s&quot;&gt;When User Sean requests to book 1 cars and 1 rooms&lt;/span&gt;

    &lt;span class=&quot;s&quot;&gt;Then Alpha records the following events&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| serviceName  | type               |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-booking | SagaStartedEvent   |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-car     | TxStartedEvent     |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-car     | TxEndedEvent       |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-hotel   | TxStartedEvent     |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-hotel   | TxEndedEvent       |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-booking | TxAbortedEvent     |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-hotel   | TxCompensatedEvent |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-car     | TxCompensatedEvent |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| pack-booking | SagaEndedEvent     |&lt;/span&gt;

    &lt;span class=&quot;s&quot;&gt;Then Car Service contains the following booking orders&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| name | amount | confirmed | cancelled |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| Sean | 1      | false     | true      |&lt;/span&gt;

    &lt;span class=&quot;s&quot;&gt;Then Hotel Service contains the following booking orders&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| name | amount | confirmed | cancelled |&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;| Sean | 1      | false     | true      |&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在行程预定的例子中仍然以4个服务启动并运行为前提，然后加载上面创建的byteman规则文件和目标服务：&lt;code class=&quot;highlighter-rouge&quot;&gt;Booking&lt;/code&gt;。然后触发预定一辆车和一间房的操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;step_definition解析&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;Given&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;^Install the byteman script ([A-Za-z0-9_\\.]+) to ([A-Za-z]+) Service$&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Install the byteman script {} to {} service&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;target/test-classes/&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Submit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getBytemanSubmit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;bm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addRulesFromFiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在Cucumber解析文件中用正则方法获取目标规则和服务名，&lt;code class=&quot;highlighter-rouge&quot;&gt;getBytemanSubmit&lt;/code&gt;根据服务名&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;参数来获取目标服务的地址和byteman监听端口，并将本地规则注入到目标服务中，注入原理是&lt;code class=&quot;highlighter-rouge&quot;&gt;Booking&lt;/code&gt;启动时是带着byteman参数启动的：&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-Dorg.jboss.byteman.debug&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; -Dorg.jboss.byteman.verbose&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;tru
-javaagent:/maven/saga/byteman.jar&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;port:9091,address:0.0.0.0,listener:true
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;bm.addRulesFromFiles(rules);&lt;/code&gt;时就可以把本地规则通过Socket发送到&lt;code class=&quot;highlighter-rouge&quot;&gt;Booking&lt;/code&gt;服务，并由Byteman完成字节替换。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结果验证&lt;/p&gt;

    &lt;p&gt;注入规则后触发预定车辆和房间服务时预定服务会出现超时，Saga会对已经完成的订车和订房间子事务进行补偿，Alpha中记录了一些列事件以及他们发生的顺序，另外Car服务和Hotel服务的取消标记&lt;code class=&quot;highlighter-rouge&quot;&gt;cancelled&lt;/code&gt;也为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;代码中使用Cucumber和Byteman要先通过pom引入相关依赖&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;io.cucumber&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;cucumber-java8&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${cucumber.version}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class=&quot;nt&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;io.cucumber&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;cucumber-junit&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${cucumber.version}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class=&quot;nt&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.jboss.byteman&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;byteman-submit&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${byteman.version}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本地运行调试需要在启动的时候使用javaagent启动byteman，建议通过修改docker-compose.yaml文件，指定可执行jar的启动参数，并修改stepdef解析文件中各个服务地址，个服务启动运行后在IDEA中运行相应的feature文件即可进行调试测试。运行调试版代码可参考&lt;a href=&quot;https://github.com/lijasonvip/incubator-servicecomb-saga/tree/debug-cucumber-byteman&quot;&gt;个人分支代码[6]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;欢迎开发者朋友们加入ServiceComb社区，一起做些有意思的事情。&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/docs/join_the_community/&quot;&gt;加入社区方法[7]&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;参考资料&quot;&gt;参考资料&lt;/h4&gt;

&lt;p&gt;[1] ServiceComb Saga  https://github.com/apache/incubator-servicecomb-saga&lt;/p&gt;

&lt;p&gt;[2] Cucumber  https://cucumber.io/&lt;/p&gt;

&lt;p&gt;[3] Saga booking demo  https://github.com/apache/incubator-servicecomb-saga/tree/master/saga-demo/booking&lt;/p&gt;

&lt;p&gt;[4] Byteman  http://byteman.jboss.org/docs.html&lt;/p&gt;

&lt;p&gt;[5] Byteman demo https://github.com/adinn/byteman-tutorial1&lt;/p&gt;

&lt;p&gt;[6] debug 分支 https://github.com/lijasonvip/incubator-servicecomb-saga/tree/debug-cucumber-byteman&lt;/p&gt;

&lt;p&gt;[7] 加入ServiceComb 社区  http://servicecomb.incubator.apache.org/cn/docs/join_the_community/&lt;/p&gt;</content><author><name>Li Bo</name><email>libo75@huawei.com</email></author><category term="Saga" /><category term="Cucumber" /><summary type="html">ServiceComb Saga使用Cucumber做验收测试源码分析</summary></entry><entry xml:lang="cn"><title type="html">Saga分布式事务解决方案与实践</title><link href="/cn/docs/distributed-transactions-saga-implementation/" rel="alternate" type="text/html" title="Saga分布式事务解决方案与实践" /><published>2018-04-26T00:00:00+08:00</published><updated>2018-04-26T17:18:43+08:00</updated><id>/cn/docs/distributed-transactions-saga</id><content type="html" xml:base="/cn/docs/distributed-transactions-saga-implementation/">&lt;h2 id=&quot;saga分布式事务解决方案与实践&quot;&gt;Saga分布式事务解决方案与实践&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.001.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.002.jpeg&quot; alt=&quot;&quot; /&gt;
我先介绍一下我自己，我叫姜宁，来自于华为开源研究中心，现在负责的是ServiceComb这个开源项目。ServiceComb这个项目已经进到Apache孵化，应该是去年11月份时进到Apache孵化的，这个月刚发了1.0M1版，但对于SAGA来说我们属于探索的阶段，我们就发了0.1.0。我参与过Apache一些项目，我也是Apache的 Member，是Apache CXF, Apache Camel 还有的PMC。还有一件事情，前一段时间帮阿里同学孵化 RocketMQ，我是以导师的身份参与的，属于见习的Mentor，这回带着ServiceComb这个项目，我感觉我把很多角色都玩了一遍。后面如果大家有兴趣，Apache孵化的事情也可以找到。还有，我之前在红帽软件、IONA、航信待过，说不定会有一些前同事，也可以找我叙旧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.003.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;今天的议题围绕几个方面来展开，一个是微服务事务一致性的问题，然后讲一讲业界的SAGA解决方案，我们在ServiceComb里也提供了SAGA的实现。另外一件事情，我项目这边也在招新，欢迎广大感兴趣的同学一会儿加我微信。我们现在项目其实架子也都搭得不错了，就是等着大家跳到碗里面，一起来解决微服务事务一致性问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.004.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;微服务架构强调的服务能够独立开发，独立演进，独立部署， 独立团队。&lt;/p&gt;

&lt;p&gt;那微服务相关的数据是采用什么方式进行存储的呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.005.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;传统的单体应用一般采用的是数据库提供的事务一致性，通过数据库提供的提交以及回滚机制来保证相关操作的ACID，这些操作要么同时成功，要么同时失败。各个服务看到数据库中的数据是一致的，同时数据库的操作也是相互隔离的，最后数据也是在数据库中持久存储的。这样的架构不具备横向扩展能力，服务之间的耦合程度也比较高，会存在单点故障。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.006.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在微服务架构中， 有一个database per service的模式， 这个模式就是每一个服务一个数据库。 这样可以保证微服务独立开发，独立演进，独立部署， 独立团队。&lt;/p&gt;

&lt;p&gt;由于一个应用是由一组相互协作的微服务所组成，在分布式环境下由于各个服务访问的数据是相互分离的， 服务之间不能靠数据库来保证事务一致性。   这就需要在应用层面提供一个协调机制，来保证一组事务执行要么成功，要么失败。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.007.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;两阶段提交其实比较简单，这边有两个资源提供准备和提交两个接口。&lt;/p&gt;

&lt;p&gt;由于隔离性互斥的要求，在事务执行过程中，所有的资源都是被锁定的，这种情况只适合执行时间确定的短事务。  但是为了保证分布式事务的一致性，大都是采用串行化的隔离级别来保证事务一致性，这样会降低系统的吞吐。&lt;/p&gt;

&lt;p&gt;但因为2PC的协议成本比较好，又有全局锁的问题，性能会比较差。 因此现在大家基本上不会采用这种强一致解决方案。我们需要做一下酸碱平衡。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.008.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里先简单介绍一下酸碱平衡中的酸 ACID。 原子性 事务作为整体来执行，要么全部执行，要么都不执行。一致性 事务应确保数据从一个一致的状态转变为另一个一致的状态。隔离性 多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性 已提交的事务修改数据会被持久保持&lt;/p&gt;

&lt;p&gt;酸碱平衡中的碱 BASE。 基本可用 可以保证分布式事务参与方不一定同时在线。柔性状态 允许系统状态更新有一定的延时，这个延时对客户来说不一定能察觉。最终一致性 通常是通过消息可达的方式保证系统的最终一致性。&lt;/p&gt;

&lt;p&gt;这是分布式事务的一些基础理论数据库以及分布式的两阶段提交都提供了ACID的保证。 由于隔离性互斥的要求，在事务执行过程中，所有的资源都是被锁定的，这种情况只适合执行时间确定的短事务。后续大家开始通过业务逻辑将互斥锁操作从资源层面上移到业务层面，这并不是完全放弃了ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.009.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TCC名字的由来是其中包含了 try, confirm, cancel三个操作。&lt;/p&gt;

&lt;p&gt;与两阶段提交相比，TCC位于业务服务层， 没有单独的准备阶段，Try操作可以灵活选择业务资源锁的粒度。TCC是通过最终一致性来解决系统性能问题的这个设计，对我们设计抉择有很大的启发。 有些时候一些系统的技术问题是可以通过业务建模的方式来解决的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.010.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​     回顾之前的酸碱平衡的示例，我们得到的启发我们可以通过业务模型的改进提升系统性能。有关领域建模，这里给大家推荐两本书，一个是《领域驱动设计》，还有一个是《实现领域驱动设计》。微服务设计目标高内聚低耦合，领域驱动设计能帮助构建一致的业务模型和系统实现模型，通过领域驱动设计可以明确微服务的界限上下文。通过在业务层面上把它们之间的强耦合关系拆开之后，带来最大的好处是，它们自身可以借助传统的数据库所提供的功能来实现一致性，只不过是在微服务与微服务之间，它们需要通过前面提到的这种柔性事务方式来做这件事情。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.011.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;微服务架构是一个在限定界限上下文内的松耦合的服务架构。微服务事务一致性的建议是什么呢？就是内刚外柔。在限定上下文内容借助数据库提供事务一致性来做强一致。在限定上下文之间依靠最终一致性方案来解决服务间协同问题。&lt;/p&gt;

&lt;p&gt;对于柔性事务来常见的实现方式有TCC，和Saga，今天我们主要向大家介绍Saga的实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.012.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Saga其实是30年前的一篇数据库论文里提到的一个概念。在论文中一个Saga事务是由多个本地事务所组成， 每个本地事务有相应的执行模块和补偿模块，当saga事务中的任意一个本地事务出错了， 可以通过调用相关的补充方法恢复之前的事务，达到事务的最终一致性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.013.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Saga概念虽然提出来快30年了， 随着微服务的复杂，引出了分布式Saga问题近些年也逐步受到大家的关注。&lt;/p&gt;

&lt;p&gt;我们在实现Saga模型的时候，主要是参考了Caitie McCaffrey 在分布式Saga论文，以及Chris Richardson的研究。 大家可以通过下面的链接获取相关的信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.016.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在分布式系统中由于网络请求可能的延时，在Caitie的论文中对被Saga调用的服务提出两点要求，我们需要Saga调用的服务支持幂等。 在服务请求的过程中，可能会出现超时重试的情况，我们需要通过幂等来避免多次请求所带来的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.017.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前面提到了超时重试的机制，现在我们再来看看重试取消的情况。补偿可交换原则是指Saga并行处理的过程中，如果发生了超时重试事件之后，并进行了补偿的操作，那么补偿操作是直接生效的。&lt;/p&gt;

&lt;p&gt;为了保证这个要求，需要我们在设计系统的过程中保留所有的事务数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.018.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此我们可以知道Saga模型只支持ACD，不提供隔离性的保证。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.019.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为saga事务没有准备阶段，事务没有隔离，如果两个saga事务同时操作同一资源就会遇到我们操作多线程临界资源的的情况。因此会产生更新丢失，脏数据读取等问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.020.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了解决隔离性带来的问题，我们可以参考一下TCC的解决方案，从业务层面入手加入一Session以及锁的机制来保证能够串行化操作资源。或者是在业务层面通过预先冻结资金的方式隔离这部分资源。 最后在业务操作的过程中可以通过及时读取当前状态的方式获取到最新的贡献。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.021.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;目前业界提供了两类Saga的实现方式。 一个是集中式协调器的实现方式，一个分布式的实现方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.022.1.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;集中式的Saga实现一般是通过一个Saga对象来追踪所有的Saga子任务的调用情况， 根据调用情况来决定是否需要调用对应的补偿方面，协调器和调用方是在一个进程中的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.022.2.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里附上的是Camel最近实现的Saga EIP， 通过这个DSL可以很方便地实现执行操作和取消操作。
集中式的Saga实现方式比较直观并且容易控制，问题是业务耦合程度会比较高。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.023.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;布式的Saga 一般是采用事件驱动方式让参与的服务方进行相关的交互。相关的业务方只需要订阅相关的领域事件即可。 Chirs提供了基于事件溯源的实现，同时axonframework也提供了相关的实现。&lt;/p&gt;

&lt;p&gt;分布式saga实现的好处： 采用事件源的方式降低系统复杂程度，提升系统扩展性， 处理模块通过订阅事件的方式降低系统的耦合程度。当然这也的实现也有一些问题： saga系统会涉及大量的业务事件，对编码和调试会带来一些问题；因为处理是基于事件，相关事件处理模块可能会循环依赖的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.024.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前面理论铺垫已经做完了，现在讲一讲我们的实现。 ServiceComb是去年5月份华为开源的微服务框架，它是华为云微服务框架引擎很重要的一个组成部分。大家可以通过下面链接来访问ServiceComb官网以及相关的代码库。&lt;/p&gt;

&lt;p&gt;目前ServiceComb主要有三个项目组成：第一个是ServiceCenter做服务发现的，这是go语言在etcd
基础实现的服务注册中心，另外是java的一个微服务框架，这块是基于vertx的基础上实现了全异步操作接口，框架有比较好的性能。 SAGA其实就是我们针对前面刚刚提到Saga模式的实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.025.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;集中式的Saga协调器构建过程参考了Caitie的论文，实现了一个集中式Saga调用协调器。 后续我们在开发的过程中，发现如果不提供DSL的话，让用户定义Saga事件很困难，受到Zipkin的启发，我们实现了一个分布式的Saga协调器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.026.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;集中式的协调器，包含了Saga调用请求接收，分析，以及执行和结果查询这部分的内容。任务代理模块需要预先知道Saga事务调用关系图。执行模块根据生成的调用图产生调用任务，调用相关微服务服务接口。如果服务调用执行出错，会调用服务的相关的补偿方法回滚。&lt;/p&gt;

&lt;p&gt;下面是我们实现的两个不同的调度模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.027.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里Saga执行模块通过分析请求的Json数据，构建一个调用关系图，这里我们是通过JSon来描述Saga事务串行调用子事务或者并行调用子事务。关系调用图被Saga实现中的任务运行模块分解成为一个一个执行任务，执行任务由任务消费者获取并生成相关的调用 （这里同时支持串行和并行调用）。&lt;/p&gt;

&lt;p&gt;Saga任务会根据执行的情况向Saga log中记录对应的Saga事务的关键事件，同时我们的事件查看器查看到Saga事务相关的执行情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.028.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;后续我们采用了Actor模型对任务的调度模块进行了重构，在不进行调优的情况下，系统性能提升一倍。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.029.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;集中式Saga的实现的好处是易于监控和协调， 但是坏处就是需要依赖工具对Saga调用进行相关的描述。那我们有没有一个好的方式自动获取Saga事务的定义呢？ 为了解决这一问题，我们对内部的Saga实现进行新的改进。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.030.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正如前面提到的，Zipkin通过在服务调用双方传递上下文的方式可以构建出完整的调用链， 这个调用链和我们需要的Saga子事务调用信息很类似。 因此我们借助Zipkin实现了一套Saga调用关系追踪的模块。&lt;/p&gt;

&lt;p&gt;为了实现这个事务追踪模型，就需要我们在应用端部署相关的监控模块，同时监控模块需要和后台进行协同交互，于是我们设计了Pack狼群架构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.031.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;狼群架构有两个参与者， 一个是Alpha， 一个是Omega。Alpha是狼群首领，负责协调事务执行情况，Omega是狼群成员，负责收集事务，向狼群首领上报情况，并执行相关指令。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.032.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Omega会以切面编程的方式向应用程序注入相关的处理模块，这里有拦截请求的模块， 用来帮助我们构建分布式事务调用的上下文。 同时在事务处理初始阶段处理事务的相关准备的操作，例如创建Saga 起始事件，以及相关的子起始事件， 根据事务的执行的成功或者失败生产相关的事务终止或者失败事件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.033.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Omega会与Alpha进行链接会把这些事件通知给Alpha。 Alpha可以在后台进行分析，根据Saga事务执行的情况给Omega下达相关的指令进行相关的回滚恢复。&lt;/p&gt;

&lt;p&gt;这样设计的好处是Saga实现代码与用户的代码分离， 用户只需要添加几个annotation，Saga实现就能Saga事件的执行情况并进行相关的处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.034.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是Omega和Alpha之间的正常业务逻辑的交互图，这里Omega通过分析调用上下文决定是否发生Saga事务的起始事件到Alpha，后续ServiceA在调用ServiceB，会将相关的调用上下文传递给ServiceB。ServiceB的Omega模块会截取这个调用上下文生成相关子事务事件信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.035.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果服务调用的过程中抛出异常，Omega会将终止事件发送到Alpha端， Alpha的后台进程会定时做扫描，扫描过程中会发现有需要恢复的事件。Alpha会向Omega发消息调用相关的恢复操作，来保证整个Saga事务的原子性。目前Omega也开始提供重试功能，也就是事务调用如果失败了， Omega会根据设置进行重试尝试。
&lt;img src=&quot;/assets/images/saga/Saga.036.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;未来的开发计划，第一个就是Alpha这边会做多租，因为这边我们可以提供线上的服务，还有为了保证系统的可达性，我们可能会用消息队列的方式的方式来做。还有就是刚刚给大家提到的TCC协调器的方式。还有就是Omega，我们要实现幂等也比较费劲，在Omega端也可以实现幂等操作。另外根据Saga的执行这个情况，也要做一些可视化的事情，这块其实也是前端，大家如果有做前端技能的话，可以跟我联系一下。最后我们要解决多线程共享调用的问题。我们问题都列在下面的JIRA上面，大家可以来找一下相关的任务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.037.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;简单小节一下，我们对事务一致性做了简单的回顾，业界的SAGA解决方案也提了一下，简单介绍一下ServiceComb的Saga实现，以及我们后续的开发计划。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.038.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个最关键了，大家扫码，上面是ServiceComb小助手，可以帮你拉到微信群里，如果大家有兴趣想加入到我们SAGA项目开发可以与ServiceComb小助手联系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/saga/Saga.039.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Willem Jiang</name></author><category term="Saga" /><category term="QCon" /><summary type="html">2018年QConBeijing Saga分布式事务解决方案与实践演讲实录</summary></entry><entry xml:lang="cn"><title type="html">如何设计一个优质的微服务框架：Apache ServiceComb 的开放性设计</title><link href="/cn/docs/open-design/" rel="alternate" type="text/html" title="如何设计一个优质的微服务框架：Apache ServiceComb 的开放性设计" /><published>2018-04-25T00:00:00+08:00</published><updated>2018-04-25T00:00:00+08:00</updated><id>/cn/docs/open-design</id><content type="html" xml:base="/cn/docs/open-design/">&lt;p&gt;【摘要】 一个优质的微服务框架需要考虑的要素众多，在满足微服务设计理念的前提下，也是一个不断实践优化的过程。  &lt;br /&gt;
本文讲述了整个 开源微服务框架 Apache ServiceComb 设计形成的前因后果，尝试从理念、思想和实践结合的维度剖析一个优质的微服务框架应该具备哪些要素，包括但不限于 对开发者友好、高性能、内外部扩展性等。  &lt;br /&gt;
阅读本文有利于加深对微服务理念和框架的理解，给予微服务用户或开发者以帮助，这也是 Apache ServiceComb 的前身华为云微服务引擎的智慧结晶，从细节处承载了华为云自身多年云化转型的经验。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;开源微服务框架 Apache ServiceComb&lt;/a&gt; 的前身为华为云的 &lt;a href=&quot;https://support.huaweicloud.com/usermanual-servicestage/zh-cn_topic_0053812706.html&quot;&gt;微服务引擎 CSE (Cloud Service Engine) 云服务&lt;/a&gt;,  ServiceComb 的早期版本和多数第一批做微服务或分布式框架先贤一样，为了追求高性能，做过非常多如 改善编码效率 和改进通信协议等尝试。然而，随着业务规模的递增，需求也逐渐呈现多样化，单方面通过传统手段追求高性能导致在面对多样化需求时遇到了各种挑战，遗留系统的通信、接入各种不同的终端、协议健壮性、防攻击等各种挑战迎面而来。&lt;/p&gt;

&lt;p&gt;Apache ServiceComb，愿景是帮助企业快速构建云原生应用，通过一系列解决方案帮助用户快速开发微服务应用的同时实现对这些微服务应用的高效运维管理，保持中立性以避免厂商LockIn成为了关键任务。对于此， Apache ServiceComb 需要有友好的机制能够对接各微服务主流技术栈技术 或 开发框架。&lt;/p&gt;

&lt;p&gt;在系列挑战的驱动下， Aapche ServiceComb 设计团队逐步形成了 “全面开放，使用标准协议，架构易于拆分和扩展，对开发人员友好，可以与业界其他主流框架互通集成” 的共识， 本文将着重分享这些共识是如何体现在Apache ServiceComb 的设计中的。&lt;/p&gt;

&lt;h2 id=&quot;开放和标准&quot;&gt;开放和标准&lt;/h2&gt;

&lt;p&gt;开放和标准应用到设计的不同的层面。一方面是连接组织和开发人员，一方面是连接异构系统。组织和开发人员的复杂性来源于技能的多样性，大家使用不同的开发语言，同一种开发语言存在多样的开发习惯；系统的多样性来源于系统之间的通信协议，为了实现与异构系统的通信，必须具备良好的适配不同通信协议的能力。&lt;/p&gt;

&lt;h3 id=&quot;连接组织和开发人员&quot;&gt;连接组织和开发人员&lt;/h3&gt;

&lt;h4 id=&quot;编程风格&quot;&gt;编程风格&lt;/h4&gt;

&lt;p&gt;每位技术人员都或多或少拥有自己的 Coding 习惯或爱好的技术， 使用个人熟练的方式从事技术工作往往更加高效和舒适。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;开源微服务框架 Apache ServiceComb&lt;/a&gt; 的早期版本实现了 gRPC 协议，然而在项目演进过程中我们发现大量技术人员并不熟悉书写 IDL ， 对 IDL 具体支持哪些特性也不清楚。 大多数情况下，用户每碰到一个场景就需要翻开协议规范看一遍， 而 IDL 缺少配套的编辑或语法检查等工具也导致了开发效率的降低。&lt;/p&gt;

&lt;p&gt;于是 Apache ServiceComb 设计团队开始思考是否有方法能够在确保保持用户开发习惯的前提下支持 gRPC 。&lt;/p&gt;

&lt;p&gt;设计团队结合自己的 Java 编程史，分析当下主流框架，并听取社区用户的反馈找到了一些共性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用 RPC 方式描述对外接口。gRPC 、Corba 、WebService 等技术人员谙于此道。&lt;/li&gt;
  &lt;li&gt;使用 JAX-RS 或 Spring MVC 风格开发 REST 接口。REST 风格开发随着微服务架构兴起，JAX-RS 和 Spring MVC 已然成为 Java REST 的开发事实标准， Spring 的拥抱者都比较熟悉。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apache ServiceComb 很快在社区设计层面达成了一致，通过缺省支持以上共性来拥抱90%的开发者， 让大多数的 Java 开发者们能够快速开始工作。&lt;/p&gt;

&lt;p&gt;除以上共识外，Apache ServiceComb 还额外做了进一步的优化，以保证不同编程风格的兼容性，使用户或开发者倍感灵活及舒适。&lt;/p&gt;

&lt;p&gt;在下面的例子中，展示了 Provider和Consumer 代码的各种实现，在同一个微服务中，这些编程方式可以同时出现；同一段 Consumer 代码中可以访问各种不同的编程风格的 Provider 实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RPC 方式的 Provider&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@RpcSchema&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;schemaId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HelloImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Helloperson&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;JAX-RS 方式的 Provider&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;代码片段来自于 &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/samples/jaxrs-sample&quot;&gt;Apache ServiceComb JAX-RS sample&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@RestSchema&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;schemaId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jaxrsHello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/jaxrshello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Produces&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MediaType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;APPLICATION_JSON&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JaxrsHelloImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/sayhi&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@POST&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/sayhello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@POST&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Helloperson&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Spring MVC 方式的 Provider&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;代码片段来自于 &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/samples/springmvc-sample&quot;&gt;Apache ServiceComb Spring MVC sample&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@RestSchema&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;schemaId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;springmvcHello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/springmvchello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;produces&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MediaType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;APPLICATION_JSON&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SpringmvcHelloImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/sayhi&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RequestMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@RequestParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/sayhello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RequestMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@RequestBody&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Helloperson&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;RPC 方式访问上述三种服务的 Consumer&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@RpcReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;microserviceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;schemaId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Hello&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;JavaChassis&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;以上代码片段全部出自 &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/samples/&quot;&gt;Apache ServiceComb Samples&lt;/a&gt;，有兴趣者可阅读了解或贡献更多的智慧。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;直至此处，或许开发者会产生疑问，既然 Consumer 可以通过一致的 API 方式访问不同的Provider，为何还需要额外的 JAX-RS 和 Spring MVC 标签？&lt;/p&gt;

&lt;p&gt;原因是，这里的设计依据是 &lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;Apache ServiceComb&lt;/a&gt;的 Consumer考虑的不仅限于 类SDK 的 Consumer，还有浏览器等非 SDK 类的 Consumer，浏览器的 Conumer 识别的是 Http 形式的消息。 通过定义和使用这些标签， 我们可以更加精细的指定浏览器如何访问后台接口。 类似于 Web Service 的 WSDL 描述语言， Apache ServiceComb 称之为&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/users/service-contract/&quot;&gt;服务契约&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;服务的契约会在服务运行时通过代码定义自动生成，并注册到&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-service-center&quot;&gt;服务中心&lt;/a&gt;。契约也可在运行时用于独立的服务治理逻辑开发，生成 Consumer 代码。此外，也可作为 API 文档对外发布，供非 SDK 的 Consumer 参考。&lt;/p&gt;

&lt;h4 id=&quot;服务契约&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/users/service-contract/&quot;&gt;服务契约&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;微服务强调服务自治，对外体现的功能全部以松耦合的接口方式提供，并且只能以通信的方式实现相互访问。此原则给团队协作带来了根本性的变革。&lt;/p&gt;

&lt;p&gt;微服务的一个开发团队通常由5~6个人的全功能团队组成，端到端的完成 场景需求分析、架构功能设计、开发和运维，团队组织结构和业务系统的架构相匹配。团队建立后的核心问题就是团队之间如何进行高效的协作沟通，以决定不同微服务之间的协作通信。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;Apache ServiceComb&lt;/a&gt; 通过确保让开发人员保持自己的固有编程习惯及设计上的松耦合灵活性，让微服务团队之间可以进行高效协作，以避免在不同的微服务团队讨论编程风格受限于历史旧账而浪费宝贵的精力和时间。&lt;/p&gt;

&lt;p&gt;在 RPC 的世界里，有 Corda IDL，WSDL，ProtoBuffer 等可以参考的优秀实践， REST 风格的接口让团队之间可以通过 HTTP 语义进行沟通，但却不能像 IDL 一样描述跨语言的数据格式。Open API 的出现很好地解决了这个问题。&lt;/p&gt;

&lt;p&gt;Open API 首先是一个不断发展壮大中的开放的标准。Open API 能兼顾 RPC 、REST 等不同的开发方式，并且吸收了大量的跨语言经验，能够在不同的语言之间进行解析。&lt;/p&gt;

&lt;p&gt;对于 Java 开发者，下面的代码片段是日常所打交道的：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;type:object&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;type:integer&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果开发人员有丰富的跨语言开发经验，可以看出 Swagger 在解决跨语言编程方面API定义冲突的努力， 如 Swagger 通过 format 来定义数据类型的存储格式，以解决不同的语言在数据类型表示上的差异：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;type:object&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;type:integer&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;format:int32&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;开源微服务框架 Apache SerivceComb&lt;/a&gt; 既遵循常规开发规范也特别关注开发效率。开发者可以先写接口定义后写代码， 也可直接通过自己熟悉的方式编写写代码， 两种方式都会生成 &lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/users/service-contract/&quot;&gt;服务契约&lt;/a&gt;（Open API 描述文件），并且将内容注册到&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-service-center&quot;&gt;服务中心&lt;/a&gt;。使用者可以从服务中心下载相关的服务契约进行开发。 Apache ServiceComb 的各种治理结构也是基于契约的，可以让开发者独立于业务实现对系统进行统一的管控治理。&lt;/p&gt;

&lt;h3 id=&quot;连接异构系统&quot;&gt;连接异构系统&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;开源微服务框架 Apache ServiceComb&lt;/a&gt; 早期版本提供了gRPC、REST、SOAP等多种协议，当前主要&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/users/communicate-protocol/&quot;&gt;支持 REST 和Highway 高性能私有 RPC 两种协议&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;highway-高性能私有-rpc-协议&quot;&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/users/communicate-protocol/#highway-rpc%E5%8D%8F%E8%AE%AE&quot;&gt;Highway 高性能私有 RPC 协议&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;gRPC 相对于 REST 的最显著优点就是性能，它采用长连接、高效的二进制序列化方式，提供多种语言支持， 提供了 IDL 语言约束开发者按照标准的方式工作， 一切看起来是那么的完美。&lt;/p&gt;

&lt;p&gt;实际上，&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;Apache ServiceComb &lt;/a&gt;的第一轮重构，首选也是 gRPC 。历史第一次在&lt;a href=&quot;https://support.huaweicloud.com/usermanual-servicestage/zh-cn_topic_0053812706.html&quot;&gt;华为云 微服务引擎 CSE&lt;/a&gt; 上线以后，面对了来自网关压力挑战。&lt;/p&gt;

&lt;p&gt;网关作为业务接入端，必须高效的管理连接和保证公平，长连接容易导致拒绝服务。gRPC 程序开发完成后，开发人员无法利用系统提供的各种工具进行测试，网络包分析也变得困难，给生产环境上的开发联调造成了困难。随着业务规模的增长，gRPC 面临了诸如“其他三方系统如何与之直接通信？ 如何跨网关与它间接通信？”等更严峻的挑战。&lt;/p&gt;

&lt;p&gt;解决这些问题，将需要我们扩展和改善老的协议和程序，提供 gRPC 客户端支持，开发者需自行提供一个额外的表示层用于业务接口的逻辑转换，造成大量的重复代码。同时由于 gRPC 依赖于接口定义，并根据定义生成代码，一套代码只能跑在 gRPC 协议上，如果用户希望业务应用可以使用如 REST等其他更加灵活的方式， 就需自行重新实现一套新的代码逻辑。据以上的血泪史， gRPC 最终被 Apache ServiceComb 设计团队定义为只能在中小型系统内部之间使用，并通过协议网关与外部系统进行通信。并实现了 &lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/users/communicate-protocol/#highway-rpc%E5%8D%8F%E8%AE%AE&quot;&gt;高性能私有协议 Highway&lt;/a&gt; 作为RPC首选默认协议。&lt;/p&gt;

&lt;h4 id=&quot;rest-通信协议&quot;&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/users/communicate-protocol/&quot;&gt;REST 通信协议&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;REST 相较 gRPC ，最大的痛点是性能。&lt;/p&gt;

&lt;p&gt;多数技术人员脑海里一个不成文的根深蒂固的观点：”二进制编码效率远高于文本协议，采用二进制编码的系统的性能远高于采用文本的 HTTP ”。该观点甚至会让多数决策止步于理论，多数人甚至不愿尝试去优化 REST。&lt;/p&gt;

&lt;p&gt;可喜的是 &lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;开源微服务框架 Apache ServiceComb&lt;/a&gt; 迈出了重构 REST 底层通信实现的第一步，基于 Netty 的异步框架来替换 Tomcat 实现，实践的效果大大超出预期，部分基准测试数据结果显示比 gRPC 还好， gRPC最终输在了HTTP2 协议上的额外报文。&lt;/p&gt;

&lt;p&gt;优化后的 REST 和业界开源的其他基于二进制的 RPC 实现的性能基本持平。在一个简单的提供数据库查询的代码逻辑中，优化后的REST通信框架处理时间，占比总处理时间远小于千分之一，这意味着再继续在框架层面进行大量优化也抵不上业务应用层面最简单的一个操作带来的消耗，Apache ServiceComb对 REST 的优化已经满足要求，最终也选择了 &lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/users/communicate-protocol/&quot;&gt;REST&lt;/a&gt; 作为首选和缺省协议(HTTP + json)。&lt;/p&gt;

&lt;p&gt;我们并没有就此止步。&lt;/p&gt;

&lt;p&gt;需要迁移到 &lt;a href=&quot;https://support.huaweicloud.com/usermanual-servicestage/zh-cn_topic_0053812706.html&quot;&gt;华为云 微服务引擎 CSE&lt;/a&gt;  的业务日益增长，部分历史遗留系统也需进行对接。通信协议对应不同的开发者接口，每每增加通信协议，则需要对业务代码进行大量的重复构建，造成大量无谓消耗。这是当时的华为云化转型以及当下很多云化转型企业或者云原生企业必将面临的痛点。&lt;/p&gt;

&lt;p&gt;于是乎，通信协议层被剥离了出来，和业务代码隔离，系统运行基于契约，&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;开源微服务框架 Apache ServiceComb&lt;/a&gt; 实现通信协议扩展机制。通信协议扩展机制，帮助用户解决与 gRPC 框架、自定义二进制框架等许多遗留系统的对接通信问题。&lt;/p&gt;

&lt;p&gt;在 Apache ServiceComb 框架中，&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/users/communicate-protocol/&quot;&gt;切换协议&lt;/a&gt;非常简单，不需要修改一行业务代码。多个协议共存也是允许的。&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;ServiceComb&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;address:0.0.0.0:8084&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;highway&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;address:0.0.0.0:8094&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;扩展性&quot;&gt;扩展性&lt;/h2&gt;

&lt;p&gt;扩展性是系统进一步发展的基石。&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;开源微服务框架 Apache ServiceComb&lt;/a&gt; 创造性地将扩展性拓展到 Provider 和 Consumer，让开发者拥有一致的开发体验。&lt;/p&gt;

&lt;h3 id=&quot;内部系统结构&quot;&gt;内部系统结构&lt;/h3&gt;

&lt;p&gt;连接开发者和通信协议层面已经让系统具备了很大的扩展性。微服务化给系统解耦、团队自治带来了很大的灵活性，加快了开发生产效率，但同时带来了服务管控的复杂性，在微服务领域，不得不考虑雪崩效应、调用跟踪、性能监控与分析等实际管控治理问题。&lt;/p&gt;

&lt;p&gt;基于服务契约，&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;开源微服务框架 Apache ServiceComb&lt;/a&gt; 提供了&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/handlers&quot;&gt;动态插拔扩展的处理链机制&lt;/a&gt;，并且为这些管控治理能力提供了默认实现，用户可以灵活插拔这些处理模块，或调整它们的顺序以应对不同的处理场景，或自行实现以增加新的处理模块。Provider 和 Consumer 都会经过该处理链，这给客户端治理功能开发带来了极大的便利性。Apache ServiceComb 的运行结构如下：&lt;/p&gt;

&lt;p class=&quot;figure-caption&quot;&gt;&lt;img src=&quot;/assets/images/open-design-running-arch.png&quot; alt=&quot;running-arch&quot; class=&quot;align-center&quot; /&gt;  &lt;br /&gt;
图1 Apache ServiceComb 运行时架构&lt;/p&gt;

&lt;p&gt;Apache ServiceComb 同时支持同步和异步两种编程接口，并在通信实现上采用了纯异步方式，对于运行模型的扩展，也是基于异步回调接口的。该方式提供了比同步模式（比如 Filter）更加优雅灵活的扩展方式。&lt;/p&gt;

&lt;p&gt;在Apache ServiceComb 结构中，几个核心的扩展机制均在 &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/core/src/main/java/org/apache/servicecomb/core&quot;&gt;core 模块&lt;/a&gt; 进行定义：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/core/src/main/java/org/apache/servicecomb/core/provider/producer&quot;&gt;Producer Provider&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Provider 编程模型的扩展，通过实现这个接口，可以适配不同的 Provider编 程风格；默认支持 RPC、Spring MVC 和 JAX-RS 三种风格。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/core/src/main/java/org/apache/servicecomb/core/provider/consumer&quot;&gt;Consumer Provider&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Consumer 编程模型的扩展，通过实现这个接口，可以适配不同的 Consumer 编程风格；默认支持 RPC和RestTemplate 两种风格。RestTemplate 是 Spring MVC 提供的 REST 编程接口，可以在服务层解除接口依赖，只依赖数据模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/core/src/main/java/org/apache/servicecomb/core/handler&quot;&gt;Handler&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;处理链的接口，通过扩展该接口，可以在处理过程中插入任意的逻辑。默认已经支持&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/handlers/handler-loadbalance&quot;&gt;负载均衡&lt;/a&gt;、&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/handlers/handler-fault-injection&quot;&gt;错误注入&lt;/a&gt;、&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/handlers/handler-flowcontrol-qps&quot;&gt;流量控制&lt;/a&gt;和&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/handlers/handler-tracing-zipkin&quot;&gt;调用链跟踪&lt;/a&gt;等多个处理链。开发者可以针对 Consumer 和 Provider 定义不同的处理链，并且为访问不同的微服务定制不同的处理链。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/transports&quot;&gt;Transport&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通信协议扩展，默认支持&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/users/communicate-protocol/&quot;&gt;REST over Vertx、Rest over Servlet、Highway&lt;/a&gt;协议。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Invocation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;中立的对象。所有的运行模型都面向这个中立的对象进行编程，当定义好服务接口后，对服务的治理和服务业务逻辑的开发可并行进行。在编程模型和通信模型里面，也面向这个对象进行编解码。&lt;/p&gt;

&lt;h3 id=&quot;对接外部系统&quot;&gt;对接外部系统&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis&quot;&gt;Apache ServiceComb Java-chassis&lt;/a&gt; 预留了对接外部系统的接口，以让开发者或用户可以灵活快速切换使用第三方提供的服务，这里所指的外部系统包括但不限于：服务注册发现的服务中心、配置管控和治理的配置中心、运行监控和运维的治理中心等。&lt;/p&gt;

&lt;p&gt;下图展示了不同的开发框架支持和运行的第三方系统情况，这些基础服务都给开发者预留了可以进行支持接入的接口。&lt;/p&gt;

&lt;p class=&quot;figure-caption&quot;&gt;&lt;img src=&quot;/assets/images/open-design-third-party-plugin.png&quot; alt=&quot;third-party-plugin&quot; class=&quot;align-center&quot; /&gt;   &lt;br /&gt;
图2 Apache ServiceComb 外部扩展接入&lt;/p&gt;

&lt;p&gt;重要的扩展：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/service-registry/src/main/java/org/apache/servicecomb/serviceregistry/client&quot;&gt;ServiceRegistryClient&lt;/a&gt;:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实现这个接口以对接不同的注册服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/foundations/foundation-config&quot;&gt;ConfigCenterConfigurationSource&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实现这个接口以对接不同的配置服务。&lt;/p&gt;

&lt;p&gt;此外，ServiceComb还提供了对接&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/tracing/tracing-zipkin&quot;&gt;Zipkin&lt;/a&gt;、Servo等开源系统的功能，这些可以从&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/&quot;&gt;github代码&lt;/a&gt;中查找到对应的例子。&lt;/p&gt;

&lt;h3 id=&quot;运行环境集成&quot;&gt;运行环境集成&lt;/h3&gt;

&lt;p&gt;一个完整的业务系统不是使用RPC框架就算完成了，它们还需要其他的计算资源。对于一般的业务系统都需要访问数据库，或者基于 J2EE 的设施进行工作。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;开源微服务框架 Apache ServiceComb&lt;/a&gt; 可以以轻量级的方式运行，也可集成到其他系统框架。下面的示意图说明了 Apache ServiceComb 的一些工作环境。&lt;/p&gt;

&lt;p class=&quot;figure-caption&quot;&gt;&lt;img src=&quot;/assets/images/open-design-integrate-with-running-environment.png&quot; alt=&quot;integrate-with-running-environment&quot; class=&quot;align-center&quot; /&gt;   &lt;br /&gt;
图3 Apache ServiceComb 运行环境集成&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;若业务只需 REST 接口，可以轻量级的方式运行 Apache ServiceComb 。所有的REST接口运行于ServiceComb 提供的 Netty HTTP 之上。&lt;/li&gt;
  &lt;li&gt;若业务是基于 J2EE 来构建，那么 Apache ServiceComb 可以作为一个 Servlet ，运行于 Web 容器里面（如 Tomcat、Jetty 等）。&lt;/li&gt;
  &lt;li&gt;若业务基于 Spring Boot 生态构建，Apache ServiceComb 可作为一个starter对外提供 REST 服务，开发者可以自由使用其他基于 Spring Boot 的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于 Apache ServiceComb 使用了Spring，因此天然继承了Spring的原有优势，可和很多通用的组件很好的集成，如 mybatis、JPA 等。各种集成方式，都可以从&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;ServiceComb官网&lt;/a&gt;或者&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/demo&quot;&gt;ServiceComb 示例库&lt;/a&gt;找到对应的例子。&lt;/p&gt;

&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;

&lt;p&gt;开源微服务框架 Apache ServiceComb 的主体代码是由华为云微服务引擎捐赠给 Apache 软件基金会的，愿景是帮助企业快速构建云原生应用，通过一系列解决方案帮助用户快速开发微服务应用的同时实现对这些微服务应用的高效运维管理。本次设计团队将开放性设计部分细节点点滴滴分享出来也是为了能够解放开发者和用户。&lt;/p&gt;

&lt;p&gt;当前越来越多的贡献者已加入到 社区行列，Apache ServiceComb 会和这些志愿者们一起一如既往坚持这个理念，争取给业界带来更多好的技术和分享。也期望有更多有志者一起行动。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/docs/join_the_community/&quot;&gt;&lt;strong&gt;如何加入Apache ServiceComb 社区&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;致谢原稿作者： 刘宝&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[1] 开源微服务框架 Apache ServiceComb 官网&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://servicecomb.incubator.apache.org/cn/&quot;&gt;http://servicecomb.incubator.apache.org/cn/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] 开源微服务框架 Apache ServiceComb 代码&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis&quot;&gt;https://github.com/apache/incubator-servicecomb-java-chassis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-service-center&quot;&gt;https://github.com/apache/incubator-servicecomb-service-center&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-saga&quot;&gt;https://github.com/apache/incubator-servicecomb-saga&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] 华为云微服务引擎 CSE（Cloud Service Engine）&lt;/p&gt;

&lt;p&gt;入口 &lt;a href=&quot;https://www.huaweicloud.com/product/cse.html&quot;&gt;https://www.huaweicloud.com/product/cse.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;资料 &lt;a href=&quot;http://support.huaweicloud.com/cse_dld/index.html&quot;&gt;http://support.huaweicloud.com/cse_dld/index.html&lt;/a&gt;&lt;/p&gt;</content><author><name>Zen Lin, Bao Liu</name></author><category term="设计" /><category term="开放，扩展" /><summary type="html">本文讲述了整个 开源微服务框架 Apache ServiceComb 设计形成的前因后果，尝试从理念、思想和实践结合的维度剖析一个优质的微服务框架应该具备哪些要素，包括但不限于 对开发者友好、高性能、内外部扩展性&gt;等。</summary></entry><entry xml:lang="cn"><title type="html">使用gradle构建基于Java Chassis开发的微服务</title><link href="/cn/docs/build-java-chassis-microservices-using-gradle/" rel="alternate" type="text/html" title="使用gradle构建基于Java Chassis开发的微服务" /><published>2018-04-13T00:00:00+08:00</published><updated>2018-04-13T09:18:43+08:00</updated><id>/cn/docs/build-java-chassis-microservices-using-gradle</id><content type="html" xml:base="/cn/docs/build-java-chassis-microservices-using-gradle/">&lt;p&gt;maven和gradle都是Java世界中常用的构建工具。在&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis&quot;&gt;Java Chassis&lt;/a&gt;项目中采用了maven作为其构建工具，并在maven中心仓库定期发布其最新稳定版。然而，鉴于gradle最新发布版(4.6.0)还不支持maven的统一版本管理(BOM)功能，则在使用gradle构建基于Java Chassis开发的微服务时，需要用到Spring的&lt;a href=&quot;https://github.com/spring-gradle-plugins/dependency-management-plugin&quot;&gt;依赖管理插件&lt;/a&gt;来引入Java Chassis的版本管理来统一依赖项的版本从而避免产生版本冲突。&lt;/p&gt;

&lt;p&gt;在maven中，Java Chassis的依赖管理通过以下方式即可引入：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.servicecomb&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;java-chassis-dependencies&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0.0-m1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;type&amp;gt;&lt;/span&gt;pom&lt;span class=&quot;nt&quot;&gt;&amp;lt;/type&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;import&lt;span class=&quot;nt&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在gradle中，则需要以下三步完成，具体可参考 ：&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/pull/640/files#diff-8d0fdb4970d74d053b6585c3d5ae4cc2R36&quot;&gt;Java Chassis的PR-640&lt;/a&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;声明使用maven仓库及依赖管理插件的依赖&lt;/p&gt;

    &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;buildscript&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;repositories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mavenLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mavenCentral&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;classpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'io.spring.gradle:dependency-management-plugin:1.0.4.RELEASE'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启用依赖管理插件&lt;/p&gt;

    &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;plugin:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'io.spring.dependency-management'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;声明Java Chassis的统一依赖管理&lt;/p&gt;

    &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;dependencyManagement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;imports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mavenBom&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'org.apache.servicecomb:java-chassis-dependencies:1.0.0-m1'&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在每个子模块中都需要进行上述三步配置。&lt;/p&gt;

&lt;p&gt;对统一版本管理配置完成后，可增加程序运行入口使得命令行下也能方便的通过gradle运行应用，以便快速验证。其中，可将应用分为Spring Boot应用和非Spring Boot应用来为其添加启动入口：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Spring Boot应用&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;声明使用maven仓库及Spring Boot插件的依赖&lt;/p&gt;

        &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;buildscript&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;classpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;org.springframework.boot:spring-boot-gradle-plugin:1.4.5.RELEASE&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;repositories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mavenLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mavenCentral&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;启用Spring Boot插件&lt;/p&gt;

        &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;plugin:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'org.springframework.boot'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非Spring Boot应用&lt;/p&gt;

    &lt;p&gt;非Spring Boot应用只需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;application&lt;/code&gt;插件并指明应用入口方法即可：&lt;/p&gt;

    &lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;plugin:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'application'&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;mainClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'org.packageName.XXXMain'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Eric Lee</name><email>eric.lee.ltk@gmail.com</email><uri>https://eric-lee-ltk.github.io</uri></author><category term="gradle" /></entry><entry xml:lang="cn"><title type="html">ServiceComb数据一致性解决方案Saga演进介绍</title><link href="/cn/docs/saga_pack_design/" rel="alternate" type="text/html" title="ServiceComb数据一致性解决方案Saga演进介绍" /><published>2018-04-04T00:00:00+08:00</published><updated>2018-04-04T09:18:43+08:00</updated><id>/cn/docs/saga-pack-design</id><content type="html" xml:base="/cn/docs/saga_pack_design/">&lt;p&gt;传统的单体应用的微服务化改造过程中大多会面临数据库拆分，故而原来由数据库保证的数据一致性也一定面临重新设计和实现，此时需要引入分布式数据一致性方案来解决。常见的解决方案主要有2PC，TCC，事件驱动等，而在微服务开源项目 ServiceComb中提出并实现了使用Saga&lt;a href=&quot;https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf&quot;&gt;[1]&lt;/a&gt;来解决微服务的数据一致性难题，不同方案的对比可参考《ServiceComb中的数据最终一致性方案》&lt;a href=&quot;http://blog.csdn.net/fl63zv9zou86950w/article/details/78393439&quot;&gt;[2]&lt;/a&gt;一文。Saga是一个数据最终一致性的解决方案，它允许我们成功地执行所有事务，或在任何事务失败的情况下，补偿已成功的事务，并提供了ACID&lt;a href=&quot;https://en.wikipedia.org/wiki/ACID&quot;&gt;[3]&lt;/a&gt;中ACD的保证（由于事务是交错执行的，可能会看到其他事务的部分结果，因此不能满足隔离性要求）。因此，Saga适用于以下跨服务的事务场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;嵌套调用&lt;/strong&gt;。如网上购物时，会依次经过下单、支付服务和第三方支付这几个子事务，其中，下单依赖于支付服务的返回状态，而支付服务也包含了多种可选的支付方式，并依赖于具体支付方式返回的结果。通过Saga，可以清晰地看到一个完整事务中各个服务之间的关系，在异常时也能快速定位出现问题的子事务。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;高并发&lt;/strong&gt;。如秒杀场景下，在成功扣除库存和完成支付后方可认为秒杀成功，若成功扣除库存但支付失败则自动进行补偿（即恢复库存）。鉴于Saga只有提交和补偿两种状态，成功场景下只需对每个子事务进行一次调用即可，因此可以在高并发下保持高性能。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;调用时间长&lt;/strong&gt;。如线上购买电影票，选好座位后一般会有15分钟的支付时间。Saga仅在子事务的提交阶段对资源进行短暂的锁定，且通过超时机制确保事务超时后能自动补偿，即在规定时间内没有支付成功的话就自动释放锁定的座位，极大地简化了业务出现异常时的处理逻辑。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;saga新版本演进&quot;&gt;Saga新版本演进&lt;/h2&gt;

&lt;p&gt;新年新气象，Apache ServiceComb(incubating) Saga&lt;a href=&quot;https://github.com/apache/incubator-servicecomb-saga&quot;&gt;[4]&lt;/a&gt;（以下简称Saga）进行了演进。相对于上一版&lt;a href=&quot;http://blog.csdn.net/fl63zv9zou86950w/article/details/78393439&quot;&gt;[2]&lt;/a&gt;，新演进的设计主要有以下优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;极大提升易用性&lt;/strong&gt;。开发者只需使用2-3个注解（即启用事务服务：EnableOmega、全局事务标记：SagaStart和子事务标记：Compensable）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;更方便扩展&lt;/strong&gt;。对微服务框架的支持更友好。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据一致性与业务逻辑解耦&lt;/strong&gt;。在演进后的设计中，通过服务侧omega的引入，saga协调器的职责更为单一（只需负责协调事务的完整性），与具体业务无关，因此，开发人员可以聚焦在具体业务的开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Saga演进后的架构，如下图所示，主要包含两个组件，即alpha和omega，其中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;alpha充当协调者的角色，主要负责对事务的事件进行持久化存储以及协调子事务的状态，使其最终得以与全局事务的状态保持一致，即保证事务中的子事务要么全执行，要么全不执行。&lt;/li&gt;
  &lt;li&gt;omega是微服务中内嵌的一个agent，负责对网络请求进行拦截并向alpha上报事务事件，并在异常情况下根据alpha下发的指令执行相应的补偿或重试操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/pack.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;omega内部运行机制&quot;&gt;omega内部运行机制&lt;/h2&gt;

&lt;p&gt;omega是微服务中内嵌的一个agent，负责向alpha上报事务状态并与其它omega直接传递事务上下文信息。其中，每个服务的事务上下文包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;全局事务id(Global Tx Id)：用于唯一标识全局事务，一般在全局事务入口生成，并在整个事务过程中传递。&lt;/li&gt;
  &lt;li&gt;本地事务id(Local Tx Id)：用于唯一标识本地事务，一般由本地事务生成。&lt;/li&gt;
  &lt;li&gt;父事务id(Parent Tx Id)：用于构建子事务间的关系，可由请求上下文中构建。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如下图所示，分布式事务与用于分布式调用链追踪的zipkin&lt;a href=&quot;https://github.com/openzipkin/zipkin&quot;&gt;[5]&lt;/a&gt;的处理流程很类似，在服务提供方，omega会将请求拦截并从中提取请求信息中的全局事务id作为其自身的全局事务id（即Saga事件id），并将请求中的本地事务id作为其父事务id，且使用新生成的id作为本地事务id；在服务消费方，omega会将请求拦截并往其中添加当前的全局事务id和本地事务id。通过服务提供方和服务消费方的这种协作处理，子事务能连接起来形成一个完整的全局事务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/id_flow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;omega在预处理阶段会先向alpha发送事务开始的事件，在后处理阶段会再向alpha发送事务结束的事件。alpha在收到事件后会进行持久化的存储。因此，每个成功的子事务都有一一对应的开始及结束事件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/omega_internal.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在omega启动时会向alpha注册，使得异常或者超时场景下，alpha能通过回调向omega发送重试或补偿的命令和相应的调用参数，从而确保全局事务的一致性。&lt;/p&gt;

&lt;h2 id=&quot;具体处理流程&quot;&gt;具体处理流程&lt;/h2&gt;

&lt;h3 id=&quot;成功场景&quot;&gt;成功场景&lt;/h3&gt;

&lt;p&gt;全局事务开始前omega会先向alpha发送全局事务开始的事件，并在所有子事务完成时向alpha发送全局事务结束的事件。而每个子事务在执行前也会向alpha发送事务开始的事件，在成功执行后，会向alpha发送事务结束的事件。子事务间通过全局事务id连接在一起，但也因本地事务id而有所区分。因此，在成功场景下，每个开始的事件都会有对应的结束事件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/successful_scenario.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;异常场景&quot;&gt;异常场景&lt;/h3&gt;

&lt;p&gt;在子事务执行期间抛出异常时，omega会向alpha上报aborted事件，然后alpha会向该全局事务的其它已完成的子事务发送补偿指令，确保最终同一全局事务下的所有子事务要么都成功，要么都回滚。由于事务中没有明确指定全局事务中的参与者，因此，alpha的扫描器会定期查询事件表并找出已完成所有补偿子事务的全局事务，然后对这些全局事务添加全局事务结束事件以保证事务的完整性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/exception_scenario.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;超时场景&quot;&gt;超时场景&lt;/h3&gt;

&lt;p&gt;alpha的扫描器会定期扫描正在处理的事件状态，若发现事件超时，则会记录相应的aborted事件，然后alpha会向该全局事务的其它已完成的子事务发送补偿指令来恢复至事务开始前的状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pack/timeout_scenario.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何使用&quot;&gt;如何使用？&lt;/h2&gt;

&lt;p&gt;Saga的使用主要涵盖两方面，alpha的启动及omega的使用。&lt;/p&gt;

&lt;h3 id=&quot;alpha的启动&quot;&gt;alpha的启动&lt;/h3&gt;

&lt;p&gt;alpha启动前需要先运行数据库PostgreSQL：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d -e &lt;span class=&quot;s2&quot;&gt;&quot;POSTGRES_DB=saga&quot;&lt;/span&gt; -e &lt;span class=&quot;s2&quot;&gt;&quot;POSTGRES_USER=saga&quot;&lt;/span&gt; -e &lt;span class=&quot;s2&quot;&gt;&quot;POSTGRES_PASSWORD=password&quot;&lt;/span&gt; -p 5432:5432 postgres
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在确保数据库正常启动后，即可运行alpha：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d -p 8090:8090 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;s2&quot;&gt;&quot;JAVA_OPTS=-Dspring.profiles.active=prd&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;s2&quot;&gt;&quot;spring.datasource.url=jdbc:postgresql://{docker.host.address}:5432/saga?useSSL=false&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  alpha-server:0.1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;omega的使用&quot;&gt;omega的使用&lt;/h3&gt;

&lt;p&gt;omega的使用很简单，以一个简化的转账业务为例，同一笔转账要么转入和转出都成功，要么都失败。在这样一个业务中引入Saga，只需简单几步即可：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;引入依赖
    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.servicecomb.saga&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;omega-spring-starter&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.1.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.servicecomb.saga&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;omega-transport-resttemplate&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.1.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;添加Saga的注解及相应的补偿方法
2.1 在应用入口添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;@EnableOmega&lt;/code&gt; 的注解来初始化omega的配置并与alpha建立连接。
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nd&quot;&gt;@SpringBootApplication&lt;/span&gt;
 &lt;span class=&quot;nd&quot;&gt;@EnableOmega&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;SpringApplication&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;2.2 在全局事务的起点添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;@SagaStart&lt;/code&gt; 的注解。&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nd&quot;&gt;@SagaStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transferMoney&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;transferOut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;transferIn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;2.3 在子事务处添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;@Compensable&lt;/code&gt; 的注解并指明其对应的补偿方法。其中，补偿方法的形参列表需与子事务方法的形参列表保持一致。&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nd&quot;&gt;@Compensable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compensationMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cancel&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transferOut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;repo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reduceBalanceByUsername&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;repo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addBalanceByUsername&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;2.4 对转入服务重复第2.3步即可。&lt;/p&gt;

    &lt;p&gt;2.5 在每个服务的application.yaml中添加配置项，指明服务信息和alpha的地址信息：&lt;/p&gt;
    &lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;s&quot;&gt;spring&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;s&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;application.name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;alpha&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;s&quot;&gt;cluster&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;s&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;alpha.cluster.addresses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目前Saga的实现还存在着很多有意思且有挑战性的课题，如alpha的协调调度实现、幂等的实现及自动补偿的实现等，欢迎有志之士与我们携手一起解决数据一致性的难题，共同为完善微服务生态贡献自己的力量。&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;[1] Sagas, Hector Garcia-Molina &amp;amp; Kenneth Salem, &lt;a href=&quot;https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf&quot;&gt;https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] ServiceComb中的数据最终一致性方案，殷湘，&lt;a href=&quot;http://blog.csdn.net/fl63zv9zou86950w/article/details/78393439&quot;&gt;http://blog.csdn.net/fl63zv9zou86950w/article/details/78393439&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] ACID, Wikipedia, &lt;a href=&quot;https://en.wikipedia.org/wiki/ACID&quot;&gt;https://en.wikipedia.org/wiki/ACID&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[4] Apache ServiceComb(incubating) Saga, Apache, &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-saga&quot;&gt;https://github.com/apache/incubator-servicecomb-saga&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5] zipkin, zipkin, &lt;a href=&quot;https://github.com/openzipkin/zipkin&quot;&gt;https://github.com/openzipkin/zipkin&lt;/a&gt;&lt;/p&gt;</content><author><name>Eric Lee</name><email>eric.lee.ltk@gmail.com</email><uri>https://eric-lee-ltk.github.io</uri></author><category term="saga" /><summary type="html">Saga演进介绍</summary></entry><entry xml:lang="cn"><title type="html">如何加入ServiceComb社区</title><link href="/cn/docs/join_the_community/" rel="alternate" type="text/html" title="如何加入ServiceComb社区" /><published>2018-04-04T00:00:00+08:00</published><updated>2017-09-16T19:05:00+08:00</updated><id>/cn/docs/join_the_community</id><content type="html" xml:base="/cn/docs/join_the_community/">&lt;p&gt;近期，热衷开源和微服务的伙伴们非常关注如何加入到ServiceComb社区。ServiceComb作为开源的Apache 孵化项目，加入方式和常规的加入开源社区的方式大体一致，一般为三个阶段：1. 订阅并关注社区动态；2. 开始在开源社区提交第一份代码；3. 深度加入社区讨论并贡献，以下将详细向大家讲述如何一步步加入ServiceComb社区。&lt;/p&gt;

&lt;h3 id=&quot;step-1-订阅并关注servicecomb社区动态&quot;&gt;Step 1 订阅并关注ServiceComb社区动态&lt;/h3&gt;

&lt;p&gt;订阅和关注社区动态的途径有：即时通讯工具（社区微信群、gitter）、社区公众号、开发者邮件列表、门户网站。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;即时通讯工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;扫描下方二维码或搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;ServiceComb小助手&lt;/code&gt;加入微信群，加入后可以在微信群中咨询和求助，会有热心的伙伴和committer 及时的响应回复。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/assist.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也可使用Github账号登录gitter（地址 https://gitter.im/ServiceCombUsers/Lobby）进行在线讨论，国内的伙伴们更习惯于使用微信群进行在线交流，但为了更方便后来加入的人可以检索并查阅前期的讨论内容存档，所以ServiceComb社区推荐使用gitter。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;社区公众号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;扫描下方二维码关注公众号或微信公众号中搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;ServiceComb&lt;/code&gt;进行关注，公众号会定期的发布和推送ServiceComb近期相应资讯（干货资料、学习资源、线上活动、线下活动等）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/public.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;邮件列表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过订阅开发者邮件可以及时获取到社区开发者的邮件讨论内容，可发起讨论，也可通过回复感兴趣的讨论题目参与到讨论中（邮件内容均使用英文），另外邮件的存档功能可以方便开发者查阅历史问题的讨论过程。&lt;/p&gt;

&lt;p&gt;订阅邮件方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发送任意内容到&lt;code class=&quot;highlighter-rouge&quot;&gt;dev-subscribe@servicecomb.incubator.apache.org&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;收到来自&lt;code class=&quot;highlighter-rouge&quot;&gt;dev-help@servicecomb.apache.org&lt;/code&gt;的确认邮件后，再回复dev-help任意内容来确认订阅邮件列表即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;邮件存档内容可通过https://www.mail-archive.com/搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;ServiceComb&lt;/code&gt;获取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;门户网站&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ServiceComb门户网站是社区的官方入口，包括快速入门指南、用户手册、开发者手册、常见问题和开发博文等。&lt;/p&gt;

&lt;p&gt;网站地址: http://servicecomb.incubator.apache.org/cn/&lt;/p&gt;

&lt;h3 id=&quot;step-2-在-servicecomb-社区提交第一份代码pr&quot;&gt;Step 2 在 ServiceComb 社区提交第一份代码（PR）&lt;/h3&gt;

&lt;p&gt;当关注社区并尝试调试使用后，会发现一些简单的bug（如文档或代码格式问题等），可以通过fix简单的bug来熟悉ServiceComb社区的开发流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发现问题并提交Issue：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于ServiceComb的任务管理是在Apache JIRA上进行的，所以需要先注册并登录到JIRA。关于JIRA详细使用方法请参考JIRA使用帮助：http://servicecomb.incubator.apache.org/cn/developers/use-jira/&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;注册并登陆到 https://issues.apache.org/jira/projects/SCB，点击左侧Kanban可以看到当前待处理、处理中和已经完成的任务列表。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira-kanban.png&quot; alt=&quot;kanabn&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击&lt;strong&gt;新建&lt;/strong&gt;创建新的issue或者task进行问题或任务跟踪，选择相应的模块并添加描述信息。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/jira/create-issue.png&quot; alt=&quot;create&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任务提交到JIRA后，需要在本地进行代码开发，进行第一份代码的提交。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提交第一份代码（PR）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开发者在GitHub上fork仓库后clone到本地进行代码修改，修改完成并测试通过后可以创建PR提交代码，提交PR后系统会自动运行CI进行代码测试。测试通过后会有其他开发者或者maintainer进行review，没有问题后会被approve并merge到主干分支。具体可参考门户网站上开发者手册中的代码提交指南：&lt;/p&gt;

&lt;p&gt;http://servicecomb.incubator.apache.org/cn/developers/submit-codes/&lt;/p&gt;

&lt;p&gt;需要&lt;strong&gt;注意&lt;/strong&gt;的是，创建PR的时候，PR的title要以JIRA中对应的问题编号开头，如下图中 [SCB-327]，这样系统就会自动关联本次提交到相应JIRA任务下，方便进度跟踪。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/pr.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;刚才提交的代码经过committer的review后，如果有问题committer会进行comment，继续修改后push最新代码即可。如果没有问题会approve并merge。&lt;/p&gt;

&lt;p&gt;至此，您已经熟悉了ServiceComb社区的初级的开发流程，也是常规的社区开发方法（不同的社区承载体会有细微差异，如kubernetes的问题跟踪是直接承载github的issue上）。下一步就可以深度参与到ServiceComb的讨论并进行贡献。&lt;/p&gt;

&lt;h3 id=&quot;step-3-深度参与到servicecomb讨论并贡献&quot;&gt;Step 3 深度参与到ServiceComb讨论并贡献&lt;/h3&gt;

&lt;p&gt;由于开源社区强调开放性，当开发者想在社区里做一些较大或中长期的特性时，则需在ServiceComb社区发起特性的讨论。&lt;/p&gt;

&lt;h4 id=&quot;如何发起特性讨论&quot;&gt;如何发起特性讨论&lt;/h4&gt;

&lt;p&gt;通过邮件发Proposal到社区进行讨论，Proposal中有贴图或附加文档时可先创建好文件链接，将链接贴到邮件里即可，创建文件可以有一下两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在JIRA上创建一个对应的特性任务，并将Proposal文档添加到该任务的附件中，拷贝链接。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过github向servicecomb.io网站以blog的形式提交文件，将该blog地址拷贝到邮件中。&lt;/p&gt;

    &lt;p&gt;文档附件可参考：&lt;/p&gt;

    &lt;p&gt;http://servicecomb.incubator.apache.org/docs/service-registry-refactor-proposal/&lt;/p&gt;

    &lt;p&gt;Proposal邮件参考：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/jira/proposal-pack.png&quot; alt=&quot;proposal-pack&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当在邮件中讨论清楚特性设计后，就可以开始对应的代码开发，或对于部分小的任务（如代码bug修复、文档完善、网站优化等），其本身不需要过多讨论，则可参考上一步骤 Step 2 中的开发流程进行代码贡献。&lt;/p&gt;

&lt;p&gt;遇到其他本文章未解决的问题（如用户业务准备进行微服务技术选型或ServiceComb的概念性问题等）时，建议直接到微信群或者gitter里进行咨询并寻求帮助。&lt;/p&gt;

&lt;p&gt;社区鼓励多劳多得和技术沉淀，坚持贡献社区可以收获来自社区的礼品激励惊喜，坚持长期使用和参与社区项目的伙伴，将可能被选举成 Apache committer 或者取得更高的荣誉，希望本文能对热衷开源及ServiceComb社区的伙伴们有所帮助，也欢迎积极参加ServiceComb的线上及线下活动。&lt;/p&gt;</content><author><name>Li Bo</name><email>libo75@huawei.com</email></author><category term="加入社区" /><summary type="html">如何加入ServiceComb社区</summary></entry><entry xml:lang="cn"><title type="html">ServiceComb示例讲解微服务配置中心选型与对接</title><link href="/cn/docs/config_center_integration/" rel="alternate" type="text/html" title="ServiceComb示例讲解微服务配置中心选型与对接" /><published>2018-04-04T00:00:00+08:00</published><updated>2018-04-04T19:05:00+08:00</updated><id>/cn/docs/config-center-integration</id><content type="html" xml:base="/cn/docs/config_center_integration/">&lt;h3 id=&quot;配置中心&quot;&gt;配置中心&lt;/h3&gt;

&lt;p&gt;项目代码中经常会用到各种配置项，比如下面的代码中是从系统环境变量中获取&lt;code class=&quot;highlighter-rouge&quot;&gt;prop&lt;/code&gt; :&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEFAULT_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NumberFormatException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// handle format issues&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;类似使用环境变量或者&lt;code class=&quot;highlighter-rouge&quot;&gt;properties&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;等文件方式传入配置进而控制应用表现的方法广泛应用于开发过程中，这样做可以将外部配置与业务代码解耦，若有变动只需修改配置参数而不需要重新编译构建项目。但是这种将配置和代码放在一起的方式可能会泄露隐私信息（比如密码），因为代码可能会公开，出于安全的考虑，配置和代码分离管理的方式开始广泛使用，常见的方法比如将配置放在CI服务器上通过打包脚本打入应用包中，或者直接放到运行应用的服务器的特定目录下，或者存储到数据库中。这种方式在传统的单体应用中简单有效，但也带来一些新的挑战：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;配置变化频繁时，需要频繁的打包部署应用&lt;/li&gt;
  &lt;li&gt;不同的环境下配置项不同需要分开管理（比如测试环境和生产环境）&lt;/li&gt;
  &lt;li&gt;配置项中的隐私信息虽然避免了随代码公开而泄露，但是还是会打包到应用包中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，面对微服务爆发式增长的应用数量和服务器数量带来新的困难&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;复杂的业务对应大量的配置项&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;配置项在不同服务中可能出现冲突&lt;/li&gt;
  &lt;li&gt;对集群部署的应用配置进行修改时需要一次修改每个机器上的应用配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种背景下，中心化的配置服务即配置中心应运而生，简单来说，配置中心就是一种统一管理各种应用配置的基础服务组件，一个合格的配置中心需要满足：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;配置项容易读取和修改&lt;/li&gt;
  &lt;li&gt;添加新配置要简单直接&lt;/li&gt;
  &lt;li&gt;支持对配置的修改的检视以把控风险&lt;/li&gt;
  &lt;li&gt;可以查看配置修改的历史记录&lt;/li&gt;
  &lt;li&gt;不同部署环境支持隔离&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开源社区目前主流的配置中心有spring-cloud-config, ctrip apollo, disconf 等，下表是对其功能特性、技术路线、可用性和易用性等发面的比较[1]供参考。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;spring-cloud-config&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ctrip apollo&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;disconf&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;静态配置管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;基于file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;动态配置管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;统一管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无，需要github&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;多维度管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无，需要github&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;本地配置缓存&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;配置生效时间&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;重启或手动refresh生效&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;实时&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;实时&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;配置更新推送&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;手动触发&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;配置定时拉取&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;依赖时事件驱动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;授权、审核、审计&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无，需要github&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;配置版本管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;git做版本管理&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;界面上提供发布历史和回滚按钮&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;操作记录存数据库，无查询接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;实例配置监控&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;需要结合springadmin&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;灰度发布&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持部分更新&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;告警通知&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持，邮件方式告警&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持，邮件方式告警&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;多数据中心部署&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;配置界面&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无，通过git操作&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;统一界面&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;统一界面&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;综合比较后，ServiceComb选择了Apollo[2]作为配置中心进行对接。Apollo是携程框架部门研发并贡献到开源社区的分布式配置中心，活跃贡献者近百人。最新版本的ServiceComb Java Chassis已实现支持Apollo[1]，用户可以使用该配置中心结合Chassis中集成的Archaius实现在不需要重新启动或重新部署应用的前提下进行配置项的集中管理和动态修改。基于ServiceComb优秀的插件化设计，用户可以非常简单的对接到其他开源或自研的配置中心。&lt;/p&gt;

&lt;h3 id=&quot;使用简介&quot;&gt;使用简介&lt;/h3&gt;

&lt;h5 id=&quot;启动apollo服务&quot;&gt;启动Apollo服务&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;启动Apollo服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apollo服务可以通过docker或二进制启动，方法参考官网文档[3]，推荐使用docker启动。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/lijasonvip/apollo-image-for-servicecomb.git
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;apollo-image-for-servicecomb &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; docker-compose up
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;出现&lt;code class=&quot;highlighter-rouge&quot;&gt;apollo-quick-start | Portal started. You can visit http://localhost:8070 now!&lt;/code&gt;后表示Apollo已经启动成功，浏览器访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8070&lt;/code&gt;即可访问&lt;code class=&quot;highlighter-rouge&quot;&gt;portal&lt;/code&gt;服务，默认登录账号为&lt;code class=&quot;highlighter-rouge&quot;&gt;apollo/admin&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建应用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;登录后点击创建项目，填入应用名称，其他选默认即可，创建应用后需要进入应用点击发布才能生效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/config/create-project.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生成TOKEN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应用发布后我们需要获取一个TOKEN，在&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8070/open/manage.html&lt;/code&gt;页面填入刚才创建的应用ID和应用名称并选择项目和部门信息后点击创建即可生成一个TOKEN，保存此TOKEN并配置到Chassis应用的配置文件中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/config/token.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;引入依赖&quot;&gt;引入依赖&lt;/h5&gt;

&lt;p&gt;在Chassis应用的pom文件中引入依赖&lt;code class=&quot;highlighter-rouge&quot;&gt;config-apollo&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.servicecomb&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;config-apollo&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;添加配置&quot;&gt;添加配置&lt;/h5&gt;

&lt;p&gt;在Chassis应用的配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;microservice.yaml&lt;/code&gt;中增加以下配置：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;s&quot;&gt;apollo&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;s&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;serverUri&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http://127.0.0.1:8070&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;		&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#Apollo portal服务地址&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;serviceName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;SampleApp&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;				&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#创建应用时的AppID&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;DEV&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;								&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#env默认是DEV&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;clusters&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;					&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#cluster默认default&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;				&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#namespace默认application&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;de3c5b2e6d8535b96&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;				&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#第一步中生成的TOKEN&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;refreshInterval&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;					&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;#自动拉取配置的时间间隔&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，通过简单的4步应用已经成功的对接到了Apollo配置中心，启动应用后可以在Apollo页面通过对配置项的新增、更新、回滚等操作进行服务治理啦！Demo参考[4]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/config/configuration.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;对接配置中心&quot;&gt;对接配置中心&lt;/h3&gt;

&lt;p&gt;Chassis动态配置基于Netflix的Archaius实现[5]，Archaius扩展数据源方法参考文档[6]和demo[7]，Chassis按照[6]扩展了&lt;code class=&quot;highlighter-rouge&quot;&gt;PolledConfigurationSource&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractPollingScheduler&lt;/code&gt;，启动的时候用SPI机制找到Source接口的实现类。&lt;/p&gt;

&lt;p&gt;对接到一个新的配置中心只要扩展实现&lt;code class=&quot;highlighter-rouge&quot;&gt;ConfigCenterConfigurationSource&lt;/code&gt;接口，实现&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;方法，在&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;方法中实现连接配置中心，刷新配置项的逻辑即可。具体代码请参考[8]。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;设计配置项&lt;/p&gt;

    &lt;p&gt;对接到新的配置中心可以设计新的配置参数，定义新的工具类获取这些参数，并指定默认值，参考&lt;code class=&quot;highlighter-rouge&quot;&gt;ApolloConfig&lt;/code&gt;类对新增&lt;code class=&quot;highlighter-rouge&quot;&gt;apollo.config.serverUri&lt;/code&gt;等参数的处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;扩展Source接口&lt;/p&gt;

    &lt;p&gt;init函数实现固定时间间隔或实时获取配置中心的配置项逻辑。&lt;code class=&quot;highlighter-rouge&quot;&gt;ApolloClient&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;refreshApolloConfig&lt;/code&gt;函数启动了一个定时执行的线程刷新配置项：&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;refreshApolloConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EXECUTOR&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;scheduleWithFixedDelay&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigRefresh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serviceUri&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; 
                                &lt;span class=&quot;n&quot;&gt;firstRefreshInterval&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
                                &lt;span class=&quot;n&quot;&gt;refreshInterval&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
                                &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConfigRefresh&lt;/code&gt;线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;中会从Apollo配置中心获取最新配置项并和之前的配置项对比分析出新增、修改和删除的配置参数，然后去执行对应的更新操作。对配置项的修改更新都是基于Archaius的&lt;code class=&quot;highlighter-rouge&quot;&gt;WatchedUpdateListener&lt;/code&gt; 进而实现应用内参数的动态更新。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;加入servicecomb社区&quot;&gt;加入ServiceComb社区&lt;/h3&gt;

&lt;p&gt;ServiceComb目前在Apache基金会孵化，诚挚的欢迎开发者和用户一起参与社区讨论和贡献，加入社区的方法有订阅邮件列表，关注微信公众号，加入社区微信群等，详细方法请参考[9]。&lt;/p&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;[0] ServiceComb 项目地址 &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis&quot;&gt;https://github.com/apache/incubator-servicecomb-java-chassis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[1] 开源配置中心比较 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/FAQ&quot;&gt;https://github.com/ctripcorp/apollo/wiki/FAQ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] ctrip apollo &lt;a href=&quot;https://github.com/ctripcorp/apollo/&quot;&gt;https://github.com/ctripcorp/apollo/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] Apollo启动 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Quick-Start&quot;&gt;https://github.com/ctripcorp/apollo/wiki/Quick-Start&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[4] Chassis应用使用Apollo配置中心Demo &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/samples/config-apollo-sample&quot;&gt;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/samples/config-apollo-sample&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5] Netflix Archaius &lt;a href=&quot;https://github.com/Netflix/archaius/&quot;&gt;https://github.com/Netflix/archaius/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[6] Archaius 扩展数据源 &lt;a href=&quot;https://github.com/Netflix/archaius/wiki/Users-Guide&quot;&gt;https://github.com/Netflix/archaius/wiki/Users-Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[7] Archaius 对接Redis Demo &lt;a href=&quot;https://github.com/cnwrinc/archaius-redis&quot;&gt;https://github.com/cnwrinc/archaius-redis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[8] Chassis对接配置中心代码 &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/dynamic-config/config-apollo&quot;&gt;https://github.com/apache/incubator-servicecomb-java-chassis/tree/master/dynamic-config/config-apollo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[9] 加入ServiceComb社区 &lt;a href=&quot;https://servicecomb.incubator.apache.org/cn/docs/join_the_community&quot;&gt;https://servicecomb.incubator.apache.org/cn/docs/join_the_community&lt;/a&gt;&lt;/p&gt;</content><author><name>Li Bo</name><email>libo75@huawei.com</email></author><category term="配置中心" /><summary type="html">ServiceComb对接配置中心</summary></entry><entry xml:lang="en"><title type="html">Howto Upgrade to Zipkin2</title><link href="/docs/howto-upgrade-topzipkin2/" rel="alternate" type="text/html" title="Howto Upgrade to Zipkin2" /><published>2018-01-10T00:00:00+08:00</published><updated>2018-01-11T10:26:28+08:00</updated><id>/docs/howto-upgrade-to-zipkin-v2</id><content type="html" xml:base="/docs/howto-upgrade-topzipkin2/">&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;Java Chassis uses zipkin as the default tracing implementation.&lt;/p&gt;

&lt;p&gt;Zipkin introduced &lt;a href=&quot;http://zipkin.io/zipkin-api/#/&quot;&gt;v2 http api&lt;/a&gt; in version 1.31 which simplifies data types. There are also various other improvements and new features added to the zipkin libraries, so it seems a good time for us to follow the upstream and upgrade to zipkin2.&lt;/p&gt;

&lt;h3 id=&quot;version-matrix&quot;&gt;Version matrix&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;module&lt;/th&gt;
      &lt;th&gt;current&lt;/th&gt;
      &lt;th&gt;target&lt;/th&gt;
      &lt;th&gt;supports v2 since&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;zipkin&lt;/td&gt;
      &lt;td&gt;1.24.0&lt;/td&gt;
      &lt;td&gt;2.4.2&lt;/td&gt;
      &lt;td&gt;2.0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;brave&lt;/td&gt;
      &lt;td&gt;4.13.1&lt;/td&gt;
      &lt;td&gt;4.13.1&lt;/td&gt;
      &lt;td&gt;4.7.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;reporter&lt;/td&gt;
      &lt;td&gt;0.10.0&lt;/td&gt;
      &lt;td&gt;2.2.2&lt;/td&gt;
      &lt;td&gt;2.0.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;whats-changed&quot;&gt;What’s changed&lt;/h2&gt;

&lt;p&gt;Zipkin did a very good job on maintaining backward compatibility. All the changes that breaks compatiblity are packaged into a new group(&lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.java&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.zipkin2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.reporter&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.reporter2&lt;/code&gt;). And v1/v2 libraries can coexist.&lt;/p&gt;

&lt;p&gt;The zipkin2 library can use both v1 and v2 api to communicate with server.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;zipkin2.Span&lt;/code&gt; class changed a bit from the old &lt;code class=&quot;highlighter-rouge&quot;&gt;zipkin.Span&lt;/code&gt; class. The public fields are refactored to methods. And the &lt;code class=&quot;highlighter-rouge&quot;&gt;BinaryAnnotation&lt;/code&gt; class is removed along with &lt;code class=&quot;highlighter-rouge&quot;&gt;zipkin.Span.binaryAnnotaions&lt;/code&gt; field. It’s functionality is replaced by &lt;code class=&quot;highlighter-rouge&quot;&gt;zipkin2.Span.tags()&lt;/code&gt; method which return a &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&amp;lt;String,String&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;upgrade-to-zipkin2-for-java-chassis&quot;&gt;Upgrade to zipkin2 for Java Chassis&lt;/h2&gt;

&lt;h3 id=&quot;modify-the-maven-dependencies-to-use-the-target-version-of-related-libraries&quot;&gt;Modify the maven dependencies to use the target version of related libraries.&lt;/h3&gt;
&lt;p&gt;Change the group &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.java&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.reporter&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.zipkin2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;io.zipkin.reporter2&lt;/code&gt; respectively.&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java-chassis-dependencies/pom.xml
&lt;span class=&quot;gu&quot;&gt;@@ -50,8 +50,8 @@
&lt;/span&gt;     &amp;lt;cxf.version&amp;gt;3.1.6&amp;lt;/cxf.version&amp;gt;
     &amp;lt;logback.version&amp;gt;1.1.7&amp;lt;/logback.version&amp;gt;
     &amp;lt;brave.version&amp;gt;4.13.1&amp;lt;/brave.version&amp;gt;
&lt;span class=&quot;gd&quot;&gt;-    &amp;lt;zipkin.version&amp;gt;1.24.0&amp;lt;/zipkin.version&amp;gt;
-    &amp;lt;zipkin-reporter.version&amp;gt;0.10.0&amp;lt;/zipkin-reporter.version&amp;gt;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    &amp;lt;zipkin.version&amp;gt;2.4.2&amp;lt;/zipkin.version&amp;gt;
+    &amp;lt;zipkin-reporter.version&amp;gt;2.2.2&amp;lt;/zipkin-reporter.version&amp;gt;
&lt;/span&gt;   &amp;lt;/properties&amp;gt;
 
   &amp;lt;dependencyManagement&amp;gt;
&lt;span class=&quot;gu&quot;&gt;@@ -646,7 +646,7 @@
&lt;/span&gt; 
       &amp;lt;!-- zipkin dependencies --&amp;gt;
       &amp;lt;dependency&amp;gt;
&lt;span class=&quot;gd&quot;&gt;-        &amp;lt;groupId&amp;gt;io.zipkin.java&amp;lt;/groupId&amp;gt;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+        &amp;lt;groupId&amp;gt;io.zipkin.zipkin2&amp;lt;/groupId&amp;gt;
&lt;/span&gt;         &amp;lt;artifactId&amp;gt;zipkin&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;${zipkin.version}&amp;lt;/version&amp;gt;
       &amp;lt;/dependency&amp;gt;
&lt;span class=&quot;gu&quot;&gt;@@ -661,7 +661,7 @@
&lt;/span&gt;         &amp;lt;version&amp;gt;${brave.version}&amp;lt;/version&amp;gt;
       &amp;lt;/dependency&amp;gt;
       &amp;lt;dependency&amp;gt;
&lt;span class=&quot;gd&quot;&gt;-        &amp;lt;groupId&amp;gt;io.zipkin.reporter&amp;lt;/groupId&amp;gt;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+        &amp;lt;groupId&amp;gt;io.zipkin.reporter2&amp;lt;/groupId&amp;gt;
&lt;/span&gt;         &amp;lt;artifactId&amp;gt;zipkin-sender-okhttp3&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;${zipkin-reporter.version}&amp;lt;/version&amp;gt;
       &amp;lt;/dependency&amp;gt;

handlers/handler-tracing-zipkin/pom.xml
&lt;span class=&quot;gu&quot;&gt;@@ -50,7 +50,7 @@
&lt;/span&gt;       &amp;lt;artifactId&amp;gt;brave&amp;lt;/artifactId&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
&lt;span class=&quot;gd&quot;&gt;-      &amp;lt;groupId&amp;gt;io.zipkin.reporter&amp;lt;/groupId&amp;gt;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+      &amp;lt;groupId&amp;gt;io.zipkin.reporter2&amp;lt;/groupId&amp;gt;
&lt;/span&gt;       &amp;lt;artifactId&amp;gt;zipkin-sender-okhttp3&amp;lt;/artifactId&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;make-brave-to-use-zipkin2-instead-of-zipkin&quot;&gt;Make brave to use zipkin2 instead of zipkin&lt;/h3&gt;

&lt;p&gt;Change the zipkin.xxx import to zipkin2.xxx on imports, and most importantly, use &lt;code class=&quot;highlighter-rouge&quot;&gt;spanReporter()&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;reporter()&lt;/code&gt; for generating reporter for brave, change the api path to /api/v2/xxx when creating sender.&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;handlers/handler-tracing-zipkin/src/main/java/org/apache/servicecomb/tracing/zipkin/TracingConfiguration.java
&lt;span class=&quot;gu&quot;&gt;@@ -31,11 +31,11 @@
&lt;/span&gt; import brave.http.HttpTracing;
 import brave.propagation.CurrentTraceContext;
 import org.apache.servicecomb.config.DynamicProperties;
&lt;span class=&quot;gd&quot;&gt;-import zipkin.Span;
-import zipkin.reporter.AsyncReporter;
-import zipkin.reporter.Reporter;
-import zipkin.reporter.Sender;
-import zipkin.reporter.okhttp3.OkHttpSender;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+import zipkin2.Span;
+import zipkin2.reporter.AsyncReporter;
+import zipkin2.reporter.Reporter;
+import zipkin2.reporter.Sender;
+import zipkin2.reporter.okhttp3.OkHttpSender;
&lt;/span&gt; 
 @Configuration
 class TracingConfiguration {
&lt;span class=&quot;gu&quot;&gt;@@ -56,14 +56,15 @@ Sender sender(DynamicProperties dynamicProperties) {
&lt;/span&gt;     return AsyncReporter.builder(sender).build();
   }
 
&lt;span class=&quot;gi&quot;&gt;+
&lt;/span&gt;   @Bean
   Tracing tracing(Reporter&amp;lt;Span&amp;gt; reporter, DynamicProperties dynamicProperties,
       CurrentTraceContext currentTraceContext) {
     return Tracing.newBuilder()
         .localServiceName(dynamicProperties.getStringProperty(CONFIG_QUALIFIED_MICROSERVICE_NAME_KEY,
             DEFAULT_MICROSERVICE_NAME))
         .currentTraceContext(currentTraceContext) // puts trace IDs into logs
&lt;span class=&quot;gd&quot;&gt;-        .reporter(reporter)
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+        .spanReporter(reporter)
&lt;/span&gt;         .build();
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&quot;https://github.com/openzipkin/brave/releases/tag/4.7.1&quot;&gt;brave release notes&lt;/a&gt;, it’s stated that we need to use &lt;code class=&quot;highlighter-rouge&quot;&gt;create()&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;builder()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
   /** Configuration for how to buffer spans into messages for Zipkin */
&lt;span class=&quot;gd&quot;&gt;-  @Bean Reporter&amp;lt;Span&amp;gt; reporter() {
-    return AsyncReporter.builder(sender()).build();
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+  @Bean Reporter&amp;lt;Span&amp;gt; spanReporter() {
+    return AsyncReporter.create(sender()).build();
&lt;/span&gt;   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But this will not work. In &lt;code class=&quot;highlighter-rouge&quot;&gt;zipkin2.Reporter&lt;/code&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;create(sender)&lt;/code&gt; is actually equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;builder(sender).build()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncReporter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Span&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncReporter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncReporter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncReporter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;make-changes-according-to-the-changes-of-zipkinspan-and-zipkin2span&quot;&gt;Make changes according to the changes of zipkin.Span and zipkin2.Span.&lt;/h3&gt;

&lt;p&gt;We do not use zipkin.Span in our production code, but we do use it in our tests. Those changes are quite straight forward, we just change the accessing of fields to calling methods as described in the What’s Changed section.&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tracing/tracing-zipkin/src/test/java/org/apache/servicecomb/tracing/zipkin/ZipkinSpanAspectTest.java 
&lt;span class=&quot;gu&quot;&gt;@@ -45,7 +45,7 @@
&lt;/span&gt; import org.apache.servicecomb.tracing.zipkin.app.ZipkinSpanTestApplication;
 import org.apache.servicecomb.tracing.zipkin.app.ZipkinSpanTestApplication.CustomSpanTask;
 import org.apache.servicecomb.tracing.zipkin.app.ZipkinSpanTestApplication.SomeSlowTask;
&lt;span class=&quot;gd&quot;&gt;-import zipkin.Span;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+import zipkin2.Span;
&lt;/span&gt; 
 @RunWith(SpringRunner.class)
 @SpringBootTest(classes = {ZipkinSpanTestApplication.class, TracingConfig.class})
&lt;span class=&quot;gu&quot;&gt;@@ -74,8 +74,8 @@ public void reportedSpanContainsAnnotatedMethodInfo() throws Exception {
&lt;/span&gt; 
     await().atMost(2, SECONDS).until(() -&amp;gt; !spans.isEmpty());
 
&lt;span class=&quot;gd&quot;&gt;-    zipkin.Span span = spans.poll();
-    assertThat(span.name, is(&quot;crawl&quot;));
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    zipkin2.Span span = spans.poll();
+    assertThat(span.name(), is(&quot;crawl&quot;));
&lt;/span&gt;     assertThat(tracedValues(span), contains(SomeSlowTask.class.getMethod(&quot;crawl&quot;).toString()));
   }
   
&lt;span class=&quot;gu&quot;&gt;@@ -84,17 +84,17 @@ public void reportCustomSpanInfomation() throws Exception {
&lt;/span&gt;     customSpanTask.invoke();
     await().atMost(2, SECONDS).until(() -&amp;gt; !spans.isEmpty());
   
&lt;span class=&quot;gd&quot;&gt;-    zipkin.Span span = spans.poll();
-    assertThat(span.name, is(&quot;transaction1&quot;));
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    zipkin2.Span span = spans.poll();
+    assertThat(span.name(), is(&quot;transaction1&quot;));
&lt;/span&gt;     assertThat(tracedValues(span), contains(&quot;startA&quot;));
     
   }
 
&lt;span class=&quot;gd&quot;&gt;-  private List&amp;lt;String&amp;gt; tracedValues(zipkin.Span spans) {
-    return spans.binaryAnnotations.stream()
-        .filter(span -&amp;gt; CALL_PATH.equals(span.key) || &quot;error&quot;.equals(span.key))
-        .filter(span -&amp;gt; span.value != null)
-        .map(annotation -&amp;gt; new String(annotation.value))
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+  private List&amp;lt;String&amp;gt; tracedValues(zipkin2.Span spans) {
+    return spans.tags().entrySet().stream()
+        .filter(span -&amp;gt; CALL_PATH.equals(span.getKey()) || &quot;error&quot;.equals(span.getKey()))
+        .filter(span -&amp;gt; span.getValue() != null)
+        .map(annotation -&amp;gt; new String(annotation.getValue()))
&lt;/span&gt;         .distinct()
         .collect(Collectors.toList());
   }
&lt;span class=&quot;gu&quot;&gt;@@ -110,7 +110,7 @@ public void reportCustomSpanInfomation() throws Exception {
&lt;/span&gt;     Tracing tracing(Queue&amp;lt;Span&amp;gt; spans) {
       return Tracing.newBuilder()
           .currentTraceContext(new StrictCurrentTraceContext())
&lt;span class=&quot;gd&quot;&gt;-          .reporter(spans::add)
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+          .spanReporter(spans::add)
&lt;/span&gt;           .build();
     }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;support-both-v1-and-v2-api-of-zipkin-server&quot;&gt;Support both v1 and v2 api of zipkin server.&lt;/h3&gt;

&lt;p&gt;Our customers may be still running a zipkin server prior to 1.31 which does not support the v2 http api. So we added an option to let them specify the server api version.&lt;/p&gt;

&lt;p&gt;Supporting v1 api is built into zipkin2, so we do not need to rely on the v1 libraries. Just use the &lt;code class=&quot;highlighter-rouge&quot;&gt;SpanBytesEncoder.JSON_V1&lt;/code&gt; when building reporter and change the sender api path.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;URLConnectionSender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://localhost:9411/api/v1/spans&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;reporter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AsyncReporter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SpanBytesEncoder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;JSON_V1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That’s all, for the complete changes, please refer the &lt;a href=&quot;https://github.com/apache/incubator-servicecomb-java-chassis/pull/488&quot;&gt;pull request&lt;/a&gt; for the complete changes.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/openzipkin/zipkin/releases/tag/2.0.0&quot;&gt;Zipkin 2.0.0 release notes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/openzipkin/brave/releases/tag/4.7.1&quot;&gt;Brave 4.7.1 release notes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/openzipkin/brave/tree/master/brave&quot;&gt;Brave API V4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Yang Bo</name><email>yangbo12@huawei.com</email></author><category term="zipkin" /><summary type="html">Changes between v1 and v2 of zipkin and how Java Chassis upgraded to zipkin2</summary></entry><entry xml:lang="en"><title type="html">Proposal for refactoring service registry module in Java Chassis</title><link href="/docs/service-registry-refactor-proposal/" rel="alternate" type="text/html" title="Proposal for refactoring service registry module in Java Chassis" /><published>2017-12-19T00:00:00+08:00</published><updated>2017-12-19T09:18:43+08:00</updated><id>/docs/service-registry-refactor-proposal</id><content type="html" xml:base="/docs/service-registry-refactor-proposal/">&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;The architecture of the &lt;code class=&quot;highlighter-rouge&quot;&gt;service registry&lt;/code&gt; module in Java Chassis is as follows.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/service_registry.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;However, it has the following problems:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Low level components access high level components frequently. The cyclic relationships make the implementation complicated and introduce some redundant access points.&lt;/li&gt;
  &lt;li&gt;Low level components should be stateless to be reused by high level components. Introducing state into low level components makes it relies heavily on the high level components, causing cyclic relationships.&lt;/li&gt;
  &lt;li&gt;Hard to integrate with third-party framework. It does not provide a standalone client with cache capability inside. It also requires the configurations should be loaded from dynamic properties.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proposed-architecture&quot;&gt;Proposed Architecture&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/proposed_architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The above architecture is what the &lt;code class=&quot;highlighter-rouge&quot;&gt;service registry&lt;/code&gt; module supposed to be in my opinion. The low level components like &lt;code class=&quot;highlighter-rouge&quot;&gt;ApiManager&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;UriManager&lt;/code&gt; are stateless so they do not rely on high level components any more. Relationships between components are clear and simple.&lt;/p&gt;

&lt;p&gt;Tasks can be divided into the following parts:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/task.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are two types of tasks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Simple Task. Task that executes only once.&lt;/li&gt;
  &lt;li&gt;Period Task. Task that executes at every interval.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The result of task will convert to event and posts to the &lt;code class=&quot;highlighter-rouge&quot;&gt;EventManager&lt;/code&gt;. Any methods that subscribes that kind of event will be notified and execute the corresponding response, e.g. update the cache.&lt;/p&gt;

&lt;p&gt;Both the outside requests and chassis requests share the same interface of Configuration, they can implement their own way to load configurations. The difference between chassis requests and outside requests is that chassis requests need to manage microservice informations of their own. Besides,  chassis requests also need to provide a compatible interface for requests to use. There comes  to the component &lt;code class=&quot;highlighter-rouge&quot;&gt;RegistryUtils&lt;/code&gt;. It is responsible for the following stuff:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Initialize service registry client with configurations.&lt;/li&gt;
  &lt;li&gt;Initialization of service center service, attach with a PullTask.&lt;/li&gt;
  &lt;li&gt;Initialization of service itself, attach with RegisterTask, HeartbeatTask and WatchTask.&lt;/li&gt;
  &lt;li&gt;Provide wrapper method for service registry client.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The initialization process of service registry client is as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/client_initialization.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If the auto discovery switch is on, it need to create a period task &lt;code class=&quot;highlighter-rouge&quot;&gt;PullTask&lt;/code&gt; to make the available service center services’ information up to date.&lt;/p&gt;

&lt;p&gt;Any requests to a new microservice will create a new entry in the service registry client. Once we access the same microservice again, the client will response with the cached version which reduces communication cost with service center.&lt;/p&gt;

&lt;p&gt;Let’s checkout how the &lt;code class=&quot;highlighter-rouge&quot;&gt;Microservice&lt;/code&gt; component works. Instances and its versions are cached inside the microservice. To get an instance of a specified id, all it needs to do is lookup the cache or create a query task to update the cache. All interactions from &lt;code class=&quot;highlighter-rouge&quot;&gt;Microservice&lt;/code&gt; to  &lt;code class=&quot;highlighter-rouge&quot;&gt;ApiManager&lt;/code&gt; are done by the &lt;code class=&quot;highlighter-rouge&quot;&gt;Task&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ApiManager&lt;/code&gt; is designed to interact directly with service center as a pure client with api inside only. Its structure is as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/api_manager.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Eric Lee</name><email>eric.lee.ltk@gmail.com</email><uri>https://eric-lee-ltk.github.io</uri></author><category term="refactor" /><summary type="html">Analysis of service registry and propose a new architecture for it</summary></entry><entry xml:lang="cn"><title type="html">老司机带你刷任务 - ServiceComb JIRA入门指南</title><link href="/cn/docs/jira_beginner_guide/" rel="alternate" type="text/html" title="老司机带你刷任务 - ServiceComb JIRA入门指南" /><published>2017-11-16T00:00:00+08:00</published><updated>2017-11-16T11:43:00+08:00</updated><id>/cn/docs/jira-beginner-guide</id><content type="html" xml:base="/cn/docs/jira_beginner_guide/">&lt;p&gt;想参与社区贡献，却感觉老虎咬天，无从下口？不用担心，老司机带你一起刷新手任务！&lt;/p&gt;

&lt;p&gt;ServiceComb的所有任务托管在&lt;a href=&quot;https://servicecomb.atlassian.net&quot;&gt;ServiceComb JIRA&lt;/a&gt;上，
首先你需要&lt;a href=&quot;https://id.atlassian.com/signup?continue=https%3A%2F%2Fservicecomb.atlassian.net%2Flogin%3FredirectCount%3D1&quot;&gt;注册&lt;/a&gt;一个免费JIRA账户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.signup.png&quot; alt=&quot;jira sign up&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;登陆后请首先花几分钟上传自己的个性头像，让大家可以一眼看出哪些任务在你的掌控之下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.board.profile.png&quot; alt=&quot;jira profile&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来在菜单栏点击Boards，选择ServiceComb转到如下Kanban board。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.board.selection.png&quot; alt=&quot;jira board selection&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ServiceComb Kanban board页面分为三列：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;To Do：还未开始的任务&lt;/li&gt;
  &lt;li&gt;In Progress：进行中的任务&lt;/li&gt;
  &lt;li&gt;Done：已完成的任务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.board.png&quot; alt=&quot;jira board&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To Do列的任务卡上如果没有头像，代表这个任务无人领取，但作为新手，我怎么知道哪个任务容易上手呢？
我们很细心的为新手任务加上了绿色竖线标记，这个标记对应所有打了 &lt;code class=&quot;highlighter-rouge&quot;&gt;good-first-issue&lt;/code&gt; 标签的任务，
以便大家一眼识别，立即上手。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.good.first.issue.png&quot; alt=&quot;jira good first issue&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.story.png&quot; alt=&quot;jira story&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外，任务还按照功能模块划分了epic，这样大家可以在自己擅长的领域大显身手，或者在全新的模块挑战自己。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.epic.png&quot; alt=&quot;jira epic&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选到心仪的任务后，记得讲任务分配给自己，以免被别人抢走。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.story.assignment.png&quot; alt=&quot;jira story assignment&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外别忘了根据自己的进度，更新对应任务的状态，你可以直接拖动任务卡到对应状态列。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.status.update.png&quot; alt=&quot;jira status update&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，在完成任务后，咨询项目带队老司机，将自己的贡献添加到对应的发布版本中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jira/jira.fix.version.png&quot; alt=&quot;jira fix.version&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看到现在相信你已经跃跃欲试，赶紧加入我们一起刷任务升级吧！&lt;/p&gt;</content><author><name>Sean Yin</name><email>seanyinx@gmail.com</email><uri>http://seanyinx.github.io</uri></author><summary type="html">ServiceComb JIRA入门指南</summary></entry></feed>